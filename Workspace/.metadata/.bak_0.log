!SESSION 2012-09-26 12:26:40.393 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -data C:\SourceControl\QRef\trunk\Workspace -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_3.log
Created Time: 2012-09-27 12:27:51.755

!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:51.755
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExec)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5780, length: 0, timestamp: 3955
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:52.230
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecu)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5781, length: 0, timestamp: 3956
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:52.453
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecut)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5782, length: 0, timestamp: 3957
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:52.575
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5783, length: 0, timestamp: 3958
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:53.264
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute,)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5784, length: 0, timestamp: 3959
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:53.289
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, )
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5785, length: 0, timestamp: 3960
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:53.620
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, c)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5786, length: 0, timestamp: 3961
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:27:53.755
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5787, length: 0, timestamp: 3962
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:05.185
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if  shouldExecute
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5800, length: 0, timestamp: 3983
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:05.452
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if n shouldExecute
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5801, length: 0, timestamp: 3984
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:05.588
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if no shouldExecute
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5802, length: 0, timestamp: 3985
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:05.712
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if not shouldExecute
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5803, length: 0, timestamp: 3986
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:08.997
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(n)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5828, length: 0, timestamp: 3991
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:09.259
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(nu)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5829, length: 0, timestamp: 3992
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:09.428
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(nul)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5830, length: 0, timestamp: 3993
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:09.603
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5831, length: 0, timestamp: 3994
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:12.758
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
			
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5852, length: 1, timestamp: 4003
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:34.120
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (treceiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5454, length: 0, timestamp: 4023
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:34.330
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (toreceiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5455, length: 0, timestamp: 4024
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:34.528
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (tokreceiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5456, length: 0, timestamp: 4025
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:34.680
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (tokereceiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5457, length: 0, timestamp: 4026
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:34.827
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (tokenreceiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5458, length: 0, timestamp: 4027
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:35.099
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token,receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5459, length: 0, timestamp: 4028
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:35.216
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5460, length: 0, timestamp: 4029
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:43.995
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(t)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5789, length: 0, timestamp: 4031
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:44.154
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(to)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5790, length: 0, timestamp: 4032
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:44.369
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(tok)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5791, length: 0, timestamp: 4033
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:44.533
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(toke)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5792, length: 0, timestamp: 4034
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:44.669
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5793, length: 0, timestamp: 4035
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:45.392
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token,)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5794, length: 0, timestamp: 4036
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:45.805
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, )
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5795, length: 0, timestamp: 4037
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:54.638
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, ())
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5796, length: 0, timestamp: 4038
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:54.861
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, (e))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5797, length: 0, timestamp: 4039
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:55.122
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, (er))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5798, length: 0, timestamp: 4040
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:55.278
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, (err))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5799, length: 0, timestamp: 4041
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:55.701
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, (err,))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5800, length: 0, timestamp: 4042
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:28:56.034
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, (err, ))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5801, length: 0, timestamp: 4043
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:16.685
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token,  (err, ))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5795, length: 0, timestamp: 4044
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:17.204
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, '' (err, ))
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5796, length: 0, timestamp: 4045
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:50.252
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						ca
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5856, length: 1, timestamp: 4110
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:50.396
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						c
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5855, length: 1, timestamp: 4111
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:51.492
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(e)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5857, length: 0, timestamp: 4114
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:51.756
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(er)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5858, length: 0, timestamp: 4115
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:51.939
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5859, length: 0, timestamp: 4116
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:53.529
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err,)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5860, length: 0, timestamp: 4117
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:53.718
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, )
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5861, length: 0, timestamp: 4118
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:54.291
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, f)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5862, length: 0, timestamp: 4119
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:54.745
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, fa)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5863, length: 0, timestamp: 4120
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:54.754
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, fal)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5864, length: 0, timestamp: 4121
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:54.822
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, fals)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5865, length: 0, timestamp: 4122
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:55.012
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5866, length: 0, timestamp: 4123
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:29:58.524
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5889, length: 1, timestamp: 4134
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:09.544
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(n)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5918, length: 0, timestamp: 4151
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:09.759
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(nu)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5919, length: 0, timestamp: 4152
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:09.955
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(nul)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5920, length: 0, timestamp: 4153
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:10.114
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5921, length: 0, timestamp: 4154
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:10.300
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null,)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5922, length: 0, timestamp: 4155
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:10.432
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null, )
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5923, length: 0, timestamp: 4156
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:10.730
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null, f)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5924, length: 0, timestamp: 4157
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:11.070
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null, fa)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5925, length: 0, timestamp: 4158
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:11.238
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null, fal)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5926, length: 0, timestamp: 4159
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:11.356
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null, fals)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5927, length: 0, timestamp: 4160
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:11.566
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						cb(null, false)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5928, length: 0, timestamp: 4161
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:29.430
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6071, length: 1, timestamp: 4181
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:34.923
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(n)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6086, length: 0, timestamp: 4190
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:35.113
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(nu)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6087, length: 0, timestamp: 4191
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:35.335
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(nul)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6088, length: 0, timestamp: 4192
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:35.505
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6089, length: 0, timestamp: 4193
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:35.694
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null,)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6090, length: 0, timestamp: 4194
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:35.846
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, )
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6091, length: 0, timestamp: 4195
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:36.084
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, t)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6092, length: 0, timestamp: 4196
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:36.310
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, tu)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6093, length: 0, timestamp: 4197
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:36.480
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, tur)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6094, length: 0, timestamp: 4198
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:36.926
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, tu)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6094, length: 1, timestamp: 4199
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:37.081
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, t)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6093, length: 1, timestamp: 4200
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:37.188
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, tr)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6093, length: 0, timestamp: 4201
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:37.539
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, tru)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6094, length: 0, timestamp: 4202
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:37.637
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		options =
			hostname: "sandbox.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6095, length: 0, timestamp: 4203
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:44.117
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
		
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5618, length: 110, timestamp: 4204
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:44.418
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5617, length: 1, timestamp: 4205
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:44.667
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
		###
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		###
		

		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5616, length: 1, timestamp: 4206
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:47.026
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		

		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5489, length: 1, timestamp: 4214
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:48.349
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		

	
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5611, length: 1, timestamp: 4215
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:30:48.559
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		


		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 5610, length: 1, timestamp: 4216
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:27.327
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6193, length: 1, timestamp: 4237
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:29.813
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(n)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6202, length: 0, timestamp: 4242
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:30.087
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(nu)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6203, length: 0, timestamp: 4243
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:30.355
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(nul)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6204, length: 0, timestamp: 4244
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:30.515
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6205, length: 0, timestamp: 4245
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:46.928
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (e)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6236, length: 0, timestamp: 4253
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:47.205
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (er)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6237, length: 0, timestamp: 4254
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:47.384
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (err)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6238, length: 0, timestamp: 4255
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:55.102
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (err)
			
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6245, length: 1, timestamp: 4257
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:55.261
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (err)
		
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6244, length: 1, timestamp: 4258
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:55.409
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (err)
	
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6243, length: 1, timestamp: 4259
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:55.574
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (err)

			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6242, length: 1, timestamp: 4260
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:55.863
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (err
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6239, length: 1, timestamp: 4262
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:56.012
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (er
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6238, length: 1, timestamp: 4263
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:56.156
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (e
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6237, length: 1, timestamp: 4264
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:56.293
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if (
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6236, length: 1, timestamp: 4265
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:56.423
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if 
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6235, length: 1, timestamp: 4266
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:31:59.938
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(e)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6254, length: 0, timestamp: 4281
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:00.182
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(er)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6255, length: 0, timestamp: 4282
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:00.340
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6256, length: 0, timestamp: 4283
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:00.847
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err,)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6257, length: 0, timestamp: 4284
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:00.998
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, )
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6258, length: 0, timestamp: 4285
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:01.164
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, n)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6259, length: 0, timestamp: 4286
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:01.374
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, nu)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6260, length: 0, timestamp: 4287
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:01.577
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, nul)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6261, length: 0, timestamp: 4288
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:01.726
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 6262, length: 0, timestamp: 4289
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:36.450
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData,  (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2461, length: 0, timestamp: 4297
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:36.792
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, t (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2462, length: 0, timestamp: 4298
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:36.997
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, to (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2463, length: 0, timestamp: 4299
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:37.222
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, tok (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2464, length: 0, timestamp: 4300
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:37.457
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, toke (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2465, length: 0, timestamp: 4301
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:37.574
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, token (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2466, length: 0, timestamp: 4302
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:44.565
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData,  (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2462, length: 5, timestamp: 4303
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:44.762
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2461, length: 1, timestamp: 4304
text:><



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:46.804
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(treceiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2449, length: 0, timestamp: 4305
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:47.031
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(toreceiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2450, length: 0, timestamp: 4306
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:47.221
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(tokreceiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2451, length: 0, timestamp: 4307
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:47.364
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(tokereceiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2452, length: 0, timestamp: 4308
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:47.482
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(tokenreceiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2453, length: 0, timestamp: 4309
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:47.738
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token,receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2454, length: 0, timestamp: 4310
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-27 12:32:47.864
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2455, length: 0, timestamp: 4311
text:> <


!SESSION 2012-10-01 10:57:13.630 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jdt.core 4 4 2012-10-01 10:57:53.187
!MESSAGE JavaBuilder handling ImageBuilderInternalException while building: QRefDroid
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:793)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:114)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:46)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:184)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: Could not delete '/QRefDroid/bin/classes/com'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:352)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:352)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:798)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1941)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:780)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:114)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:46)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:184)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\SourceControl\QRef\trunk\Workspace\QRefDroid\bin\classes\com\qref.
Contains: Could not delete: C:\SourceControl\QRef\trunk\Workspace\QRefDroid\bin\classes\com.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2012-10-01 10:57:53.219
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2012-10-01 10:57:53.220
!MESSAGE Could not delete '/QRefDroid/bin/classes/com'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:352)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:352)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:798)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1941)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:780)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:114)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:46)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:184)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\SourceControl\QRef\trunk\Workspace\QRefDroid\bin\classes\com\qref.
Contains: Could not delete: C:\SourceControl\QRef\trunk\Workspace\QRefDroid\bin\classes\com.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2012-10-01 10:57:53.220
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2012-10-01 10:57:53.220
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2012-10-01 10:57:53.220
!MESSAGE Could not delete: C:\SourceControl\QRef\trunk\Workspace\QRefDroid\bin\classes\com\qref.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2012-10-01 10:57:53.220
!MESSAGE Could not delete: C:\SourceControl\QRef\trunk\Workspace\QRefDroid\bin\classes\com.

!ENTRY org.apache.log4j 4 0 2012-10-01 11:04:28.581
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('')
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1192, length: 0, timestamp: 15
text:>''<



!ENTRY org.apache.log4j 4 0 2012-10-01 11:15:49.150
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('INFO: filter.update() - User or Role not loaded. Beginning call to filter.resolve()')
						@.resolve(cb)
					else
						console.log('INFO: filter.update() - User and Role are currently loaded. Stepping into next method in series.')
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						console.log('INFO: filter.update() - User is in the Administrators role. Authorizing update request.')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						console.log('INFO: filter.update() - User in is limited access group and record is owned by the user. Authorizing update request.')
						canUpdate = true
					else 
						console.log('INFO: filter.update() - User is not authorized. Denying update request.')
						consosle
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				if err?
					console.log('ERROR: filter.update() - Error occurred in process. Dumping error to console.')
					console.log('ERROR: filter.update() - ' + err.toString())
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1985, length: 1, timestamp: 564
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 11:15:49.302
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('INFO: filter.update() - User or Role not loaded. Beginning call to filter.resolve()')
						@.resolve(cb)
					else
						console.log('INFO: filter.update() - User and Role are currently loaded. Stepping into next method in series.')
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						console.log('INFO: filter.update() - User is in the Administrators role. Authorizing update request.')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						console.log('INFO: filter.update() - User in is limited access group and record is owned by the user. Authorizing update request.')
						canUpdate = true
					else 
						console.log('INFO: filter.update() - User is not authorized. Denying update request.')
						consosl
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				if err?
					console.log('ERROR: filter.update() - Error occurred in process. Dumping error to console.')
					console.log('ERROR: filter.update() - ' + err.toString())
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1984, length: 1, timestamp: 565
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 11:15:49.463
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('INFO: filter.update() - User or Role not loaded. Beginning call to filter.resolve()')
						@.resolve(cb)
					else
						console.log('INFO: filter.update() - User and Role are currently loaded. Stepping into next method in series.')
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						console.log('INFO: filter.update() - User is in the Administrators role. Authorizing update request.')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						console.log('INFO: filter.update() - User in is limited access group and record is owned by the user. Authorizing update request.')
						canUpdate = true
					else 
						console.log('INFO: filter.update() - User is not authorized. Denying update request.')
						consos
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				if err?
					console.log('ERROR: filter.update() - Error occurred in process. Dumping error to console.')
					console.log('ERROR: filter.update() - ' + err.toString())
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1983, length: 1, timestamp: 566
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 11:15:49.635
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('INFO: filter.update() - User or Role not loaded. Beginning call to filter.resolve()')
						@.resolve(cb)
					else
						console.log('INFO: filter.update() - User and Role are currently loaded. Stepping into next method in series.')
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						console.log('INFO: filter.update() - User is in the Administrators role. Authorizing update request.')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						console.log('INFO: filter.update() - User in is limited access group and record is owned by the user. Authorizing update request.')
						canUpdate = true
					else 
						console.log('INFO: filter.update() - User is not authorized. Denying update request.')
						conso
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				if err?
					console.log('ERROR: filter.update() - Error occurred in process. Dumping error to console.')
					console.log('ERROR: filter.update() - ' + err.toString())
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1982, length: 1, timestamp: 567
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 11:15:49.839
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('INFO: filter.update() - User or Role not loaded. Beginning call to filter.resolve()')
						@.resolve(cb)
					else
						console.log('INFO: filter.update() - User and Role are currently loaded. Stepping into next method in series.')
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						console.log('INFO: filter.update() - User is in the Administrators role. Authorizing update request.')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						console.log('INFO: filter.update() - User in is limited access group and record is owned by the user. Authorizing update request.')
						canUpdate = true
					else 
						console.log('INFO: filter.update() - User is not authorized. Denying update request.')
						cons
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				if err?
					console.log('ERROR: filter.update() - Error occurred in process. Dumping error to console.')
					console.log('ERROR: filter.update() - ' + err.toString())
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1981, length: 1, timestamp: 568
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 11:15:52.980
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						console.log('INFO: filter.update() - User or Role not loaded. Beginning call to filter.resolve()')
						@.resolve(cb)
					else
						console.log('INFO: filter.update() - User and Role are currently loaded. Stepping into next method in series.')
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						console.log('INFO: filter.update() - User is in the Administrators role. Authorizing update request.')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						console.log('INFO: filter.update() - User in is limited access group and record is owned by the user. Authorizing update request.')
						canUpdate = true
					else 
						console.log('INFO: filter.update() - User is not authorized. Denying update request.')
						console.log('')
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				if err?
					console.log('ERROR: filter.update() - Error occurred in process. Dumping error to console.')
					console.log('ERROR: filter.update() - ' + err.toString())
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						query = null
						
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1989, length: 0, timestamp: 577
text:>''<



!ENTRY org.apache.log4j 2 0 2012-10-01 11:16:57.208
!MESSAGE csep.parser.Lexer  - Unexpected symbol [2,997:2,998 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.AbstractParser.parse(AbstractParser.java:27)
	at org.eclipse.xtext.resource.XtextResource.doLoad(XtextResource.java:159)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.doLoad(LazyLinkingResource.java:75)
	at org.eclipse.xtext.resource.XtextResource.reparse(XtextResource.java:183)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:62)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:14.250
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(I)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1096, length: 0, timestamp: 15
text:>I<



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:14.295
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(IN)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1097, length: 0, timestamp: 16
text:>N<



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:14.309
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(INF)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1098, length: 0, timestamp: 17
text:>F<



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:14.398
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(INFO)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1099, length: 0, timestamp: 18
text:>O<



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:14.923
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(INF)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1099, length: 1, timestamp: 19
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:15.087
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(IN)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1098, length: 1, timestamp: 20
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:15.230
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log(I)
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1097, length: 1, timestamp: 21
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:15.373
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log()
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1096, length: 1, timestamp: 22
text:><



!ENTRY org.apache.log4j 4 0 2012-10-01 14:48:15.799
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		console.log('')
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(token, receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err, checklistId) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
											attempt.isComplete = true
											attempt.checklist = checklistId
											
											attempt.save((err) ->
												if err?
													resp = new RpcResponse(null)
													resp.failure('Internal Error', 500)
													res.json(resp, 200)
													return	
												
												resp = new RpcResponse(checklistId)
												res.json(resp, 200)
												return
											)
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save((err) -> 
			if err?
				callback(err, null)
				return
			callback(null, nChecklist._id)
		)
	validateReceipt: (token, receiptData, callback) ->
	
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
	
		
		async.waterfall([
			(cb) ->
				UserAuth.isInRole(token, 'Administrators', (err, isMember) ->
					if err?
						cb(err, false)
						return
					
					if isMember
						options =
							hostname: "sandbox.itunes.apple.com"
							port: 443
							path: "/verifyReceipt"
							method: "POST"
						cb(null, false)
					else
						cb(null, true)
				)
			, (shouldExecute, cb) ->
				if not shouldExecute
					cb(null)
					return
				
				options =
					hostname: "buy.itunes.apple.com"
					port: 443
					path: "/verifyReceipt"
					method: "POST"
				
				cb(null)
		], (err) ->
			
			if err?
				callback(err, null)
				return
			
			request =
				receipt-data: receiptData
			
			requestData = JSON.stringify(request)
			
			data = ""
			
			req = https.request(options, (res) -> 
					res.setEncoding('ascii')
					
					res.on('data', (buff) ->
						data += buff
					)
					
					res.on('end', () ->
						if data? 
							response = JSON.parse(data)
							
							if not response?
								callback(new Error('Invalid JSON data received from server.'), null)
							else
								callback(null, response)
						else
							callback(new Error('No data received from the server.'), null)
					)
			)
			
			req.on('error', (err) ->
				callback(err, null)
			)
			
			req.write(requestData)
			req.end()
		)
		
		
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1096, length: 0, timestamp: 23
text:>''<


