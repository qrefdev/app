!SESSION 2012-09-26 12:26:40.393 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -data C:\SourceControl\QRef\trunk\Workspace -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_0.log
Created Time: 2012-09-26 13:19:55.665

!ENTRY org.apache.log4j 4 0 2012-09-26 13:19:55.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2445, length: 0, timestamp: 1684
text:>	<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:19:59.740
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(n)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2434, length: 0, timestamp: 1694
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:19:59.819
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(ne)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2435, length: 0, timestamp: 1695
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:00.041
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2436, length: 0, timestamp: 1696
text:>w<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:00.181
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new )
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2437, length: 0, timestamp: 1697
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:00.551
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new E)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2438, length: 0, timestamp: 1698
text:>E<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:00.815
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Er)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2439, length: 0, timestamp: 1699
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:00.990
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Err)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2440, length: 0, timestamp: 1700
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:01.091
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Erro)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2441, length: 0, timestamp: 1701
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:01.223
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2442, length: 0, timestamp: 1702
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:01.837
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error())
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2443, length: 0, timestamp: 1703
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:20:02.291
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "GET"
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error(''))
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2444, length: 0, timestamp: 1704
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:06.750
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData =
			receipt-data: recpei
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2194, length: 1, timestamp: 1791
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:06.900
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData =
			receipt-data: recpe
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2193, length: 1, timestamp: 1792
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:07.097
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData =
			receipt-data: recp
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2192, length: 1, timestamp: 1793
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:08.053
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData =
			receipt-data: rec
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2191, length: 1, timestamp: 1794
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:12.491
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData =
			receipt-data: receiptDa
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2197, length: 1, timestamp: 1802
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:20.222
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData =
			receipt-data: receiptData
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2203, length: 1, timestamp: 1806
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:27.236
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestData=
			receipt-data: receiptData
		
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2167, length: 1, timestamp: 1808
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:27.391
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestDat=
			receipt-data: receiptData
		
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2166, length: 1, timestamp: 1809
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:27.563
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestDa=
			receipt-data: receiptData
		
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2165, length: 1, timestamp: 1810
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:27.723
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		requestD=
			receipt-data: receiptData
		
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2164, length: 1, timestamp: 1811
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:28.745
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request=
			receipt-data: receiptData
		
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2163, length: 1, timestamp: 1812
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:30.868
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2163, length: 0, timestamp: 1813
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:35.755
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData 
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2215, length: 1, timestamp: 1827
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:44.931
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(r)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2232, length: 0, timestamp: 1845
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:45.195
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(re)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2233, length: 0, timestamp: 1846
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:45.415
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(req)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2234, length: 0, timestamp: 1847
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:45.590
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(requ)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2235, length: 0, timestamp: 1848
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:45.673
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(reque)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2236, length: 0, timestamp: 1849
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:45.857
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(reques)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2237, length: 0, timestamp: 1850
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:21:45.917
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2238, length: 0, timestamp: 1851
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:17.888
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(r)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2799, length: 0, timestamp: 1862
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:18.088
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(re)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2800, length: 0, timestamp: 1863
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:18.326
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(req)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2801, length: 0, timestamp: 1864
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:18.503
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(requ)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2802, length: 0, timestamp: 1865
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:18.718
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(reque)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2803, length: 0, timestamp: 1866
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:18.790
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(reques)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2804, length: 0, timestamp: 1867
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:18.908
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(request)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2805, length: 0, timestamp: 1868
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:19.370
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(requestD)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2806, length: 0, timestamp: 1869
text:>D<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:19.655
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(requestDa)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2807, length: 0, timestamp: 1870
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:19.795
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(requestDat)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2808, length: 0, timestamp: 1871
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:22:19.855
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2809, length: 0, timestamp: 1872
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:15.354
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(r)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1992, length: 0, timestamp: 1892
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:15.562
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(re)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1993, length: 0, timestamp: 1893
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:15.790
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(rec)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1994, length: 0, timestamp: 1894
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:16.019
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(rece)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1995, length: 0, timestamp: 1895
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:16.196
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(recei)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1996, length: 0, timestamp: 1896
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:16.366
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receip)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1997, length: 0, timestamp: 1897
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:16.567
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receipt)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1998, length: 0, timestamp: 1898
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:17.424
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptD)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1999, length: 0, timestamp: 1899
text:>D<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:17.743
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptDa)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2000, length: 0, timestamp: 1900
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:17.897
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptDat)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2001, length: 0, timestamp: 1901
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:17.944
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2002, length: 0, timestamp: 1902
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:18.804
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData,)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2003, length: 0, timestamp: 1903
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:18.949
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, )
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2004, length: 0, timestamp: 1904
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:19.437
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, ())
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2005, length: 0, timestamp: 1905
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:19.771
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (e))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2006, length: 0, timestamp: 1906
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:20.044
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (er))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2007, length: 0, timestamp: 1907
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:20.231
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2008, length: 0, timestamp: 1908
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:20.940
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err,))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2009, length: 0, timestamp: 1909
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:21.081
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, ))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2010, length: 0, timestamp: 1910
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:22.708
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, r))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2011, length: 0, timestamp: 1911
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:22.913
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, re))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2012, length: 0, timestamp: 1912
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:23.144
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, rec))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2013, length: 0, timestamp: 1913
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:23.368
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, rece))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2014, length: 0, timestamp: 1914
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:23.526
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, recei))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2015, length: 0, timestamp: 1915
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:23.676
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receip))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2016, length: 0, timestamp: 1916
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:23.816
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt))
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2017, length: 0, timestamp: 1917
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:24.802
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) )
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2019, length: 0, timestamp: 1918
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:25.372
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) -)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2020, length: 0, timestamp: 1919
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:25.871
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2021, length: 0, timestamp: 1920
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:26.568
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2022, length: 0, timestamp: 1921
text:>
						
					<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:45.706
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(n)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2069, length: 0, timestamp: 1953
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:45.961
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(nu)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2070, length: 0, timestamp: 1954
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:46.142
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(nul)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2071, length: 0, timestamp: 1955
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:46.281
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2072, length: 0, timestamp: 1956
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:23:52.894
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('')
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2096, length: 0, timestamp: 1971
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:04.171
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(r)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2136, length: 0, timestamp: 2003
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:04.356
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(re)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2137, length: 0, timestamp: 2004
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:04.555
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(res)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2138, length: 0, timestamp: 2005
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:04.674
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2139, length: 0, timestamp: 2006
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:04.991
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp,)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2140, length: 0, timestamp: 2007
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:05.114
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, )
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2141, length: 0, timestamp: 2008
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:11.119
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 2)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2142, length: 0, timestamp: 2009
text:>2<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:11.364
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 20)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2143, length: 0, timestamp: 2010
text:>0<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:11.493
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2144, length: 0, timestamp: 2011
text:>0<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:24:49.123
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2178, length: 1, timestamp: 2021
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:25:32.120
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2185, length: 1, timestamp: 2030
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:25:43.867
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2334, length: 1, timestamp: 2043
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:25:49.323
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if rece
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2341, length: 1, timestamp: 2052
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:25:51.748
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if receipt.sa
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2347, length: 1, timestamp: 2060
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:25:51.943
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if receipt.s
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2346, length: 1, timestamp: 2061
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:01.302
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if nreceipt.status 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2337, length: 0, timestamp: 2068
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:01.437
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if noreceipt.status 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2338, length: 0, timestamp: 2069
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:01.502
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if notreceipt.status 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2339, length: 0, timestamp: 2070
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:01.646
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2340, length: 0, timestamp: 2071
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:03.380
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status  
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2355, length: 0, timestamp: 2072
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:03.772
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status = 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2356, length: 0, timestamp: 2073
text:>=<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:03.929
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status == 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2357, length: 0, timestamp: 2074
text:>=<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:04.040
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status ==  
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2358, length: 0, timestamp: 2075
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:04.264
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status == 0 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2359, length: 0, timestamp: 2076
text:>0<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:05.472
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt.status == 0
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2360, length: 0, timestamp: 2077
text:>
							<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:26:31.015
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2334, length: 26, timestamp: 2078
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:35.854
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId), (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1654, length: 0, timestamp: 2079
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:36.394
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					, (err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1655, length: 0, timestamp: 2080
text:>
					<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:38.091
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					,(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1663, length: 1, timestamp: 2081
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:38.299
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1662, length: 1, timestamp: 2082
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:40.158
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					.(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1662, length: 0, timestamp: 2083
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:40.363
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					.e(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1663, length: 0, timestamp: 2084
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:40.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					.ex(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1664, length: 0, timestamp: 2085
text:>x<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:40.821
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					.exe(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1665, length: 0, timestamp: 2086
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:41.054
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					.exec(err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1666, length: 0, timestamp: 2087
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:42.118
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1667, length: 0, timestamp: 2088
text:>(<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:44.347
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
					
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1662, length: 0, timestamp: 2089
text:>
						<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:27:49.270
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							 
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 1673, length: 0, timestamp: 2101
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:28:07.982
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
							
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2394, length: 1, timestamp: 2119
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:28:09.472
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2393, length: 1, timestamp: 2120
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:28:43.301
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2387, length: 1, timestamp: 2124
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:28:43.471
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						i
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2386, length: 1, timestamp: 2125
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:28:43.642
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2385, length: 1, timestamp: 2126
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:13.799
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftModeSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 385, length: 1, timestamp: 3
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:13.961
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftModSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 384, length: 1, timestamp: 4
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:14.111
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftMoSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 383, length: 1, timestamp: 5
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:14.269
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftMSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 382, length: 1, timestamp: 6
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:14.424
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 381, length: 1, timestamp: 7
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:14.584
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircrafSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 380, length: 1, timestamp: 8
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:14.754
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 379, length: 1, timestamp: 9
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:14.894
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircrSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 378, length: 1, timestamp: 10
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:15.047
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 377, length: 1, timestamp: 11
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:15.217
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AirSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 376, length: 1, timestamp: 12
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:15.986
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AiSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 375, length: 1, timestamp: 13
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:16.184
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class ASchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 374, length: 1, timestamp: 14
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:19.450
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AiSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 374, length: 0, timestamp: 15
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:19.641
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AirSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 375, length: 0, timestamp: 16
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:20.056
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 376, length: 0, timestamp: 17
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:20.333
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircrSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 377, length: 0, timestamp: 18
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:20.451
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 378, length: 0, timestamp: 19
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:20.659
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircrafSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 379, length: 0, timestamp: 20
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:20.773
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 380, length: 0, timestamp: 21
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:21.386
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftPSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 381, length: 0, timestamp: 22
text:>P<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:21.839
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftPrSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 382, length: 0, timestamp: 23
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:21.986
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 383, length: 0, timestamp: 24
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:22.158
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProdSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 384, length: 0, timestamp: 25
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:22.353
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProduSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 385, length: 0, timestamp: 26
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:22.685
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProducSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 386, length: 0, timestamp: 27
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:22.772
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 387, length: 0, timestamp: 28
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:23.596
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductASchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 388, length: 0, timestamp: 29
text:>A<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:23.776
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 389, length: 0, timestamp: 30
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:23.978
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAutSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 390, length: 0, timestamp: 31
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:24.081
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 391, length: 0, timestamp: 32
text:>h<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:24.346
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthoSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 392, length: 0, timestamp: 33
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:24.487
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 393, length: 0, timestamp: 34
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:24.646
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthoriSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 394, length: 0, timestamp: 35
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:24.838
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 395, length: 0, timestamp: 36
text:>z<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:25.108
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizaSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 396, length: 0, timestamp: 37
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:25.250
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizatSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 397, length: 0, timestamp: 38
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:25.488
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizatiSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 398, length: 0, timestamp: 39
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:25.571
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizatioSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 399, length: 0, timestamp: 40
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:25.733
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 400, length: 0, timestamp: 41
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:26.136
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationASchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 401, length: 0, timestamp: 42
text:>A<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:26.361
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAtSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 402, length: 0, timestamp: 43
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:26.510
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 403, length: 0, timestamp: 44
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:26.670
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAtteSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 404, length: 0, timestamp: 45
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:26.920
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 405, length: 0, timestamp: 46
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:27.155
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttempSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 406, length: 0, timestamp: 47
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:27.339
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftModelSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 407, length: 0, timestamp: 48
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:36.187
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftModelSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1067, length: 27, timestamp: 49
text:>AircraftProductAuthorizationAttemptSchemaInternal<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:39.250
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaInternal = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1030, length: 19, timestamp: 50
text:>AircraftProductAuthorizationAttemptSchemaInternal<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:40.344
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaInterna = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1078, length: 1, timestamp: 51
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:40.509
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaIntern = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1077, length: 1, timestamp: 52
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:40.676
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaInter = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1076, length: 1, timestamp: 53
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:40.821
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaInte = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1075, length: 1, timestamp: 54
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:40.971
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaInt = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1074, length: 1, timestamp: 55
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:41.133
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaIn = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1073, length: 1, timestamp: 56
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:41.302
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchemaI = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1072, length: 1, timestamp: 57
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:41.452
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftModelSchema<<<
Document event: offset: 1071, length: 1, timestamp: 58
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:45.962
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftModelSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1231, length: 19, timestamp: 59
text:>AircraftProductAuthorizationAttemptSchema<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:48.432
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ name: 1, modelYear: 1}, { unique: true })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1143, length: 19, timestamp: 60
text:>AircraftProductAuthorizationAttemptSchema<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:58.498
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ n
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1194, length: 40, timestamp: 61
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:58.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ 
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1193, length: 1, timestamp: 62
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:30:59.603
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ )
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1193, length: 0, timestamp: 63
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:02.645
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ )
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1194, length: 1, timestamp: 65
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:02.802
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ 
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1193, length: 1, timestamp: 66
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:03.457
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ }
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1193, length: 0, timestamp: 67
text:>}<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:04.578
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1194, length: 0, timestamp: 68
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:26.361
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 429, length: 1, timestamp: 75
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:32.610
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 429, length: 5, timestamp: 75
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:33.653
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 425, length: 5, timestamp: 69
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:48.243
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: Obbjec

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 447, length: 1, timestamp: 99
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:48.388
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: Obbje

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 446, length: 1, timestamp: 100
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:48.555
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: Obbj

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 445, length: 1, timestamp: 101
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:48.708
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: Obb

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 444, length: 1, timestamp: 102
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:48.877
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: Ob

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 443, length: 1, timestamp: 103
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:31:57.253
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 470, length: 1, timestamp: 126
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:12.959
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: 

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 504, length: 1, timestamp: 155
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:25.045
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 552, length: 1, timestamp: 195
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:44.038
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	appl

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 556, length: 1, timestamp: 201
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:44.197
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	app

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 555, length: 1, timestamp: 202
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:44.374
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	ap

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 554, length: 1, timestamp: 203
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:44.542
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	a

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 553, length: 1, timestamp: 204
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:32:44.705
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 552, length: 1, timestamp: 205
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:14.142
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['']

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 609, length: 0, timestamp: 254
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:21.888
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 631, length: 1, timestamp: 271
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:32.820
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	apple

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 636, length: 1, timestamp: 278
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:35.952
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReques

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 642, length: 1, timestamp: 286
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:36.059
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReque

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 641, length: 1, timestamp: 287
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:36.232
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleRequ

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 640, length: 1, timestamp: 288
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:36.392
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReq

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 639, length: 1, timestamp: 289
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:36.554
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleRe

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 638, length: 1, timestamp: 290
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:36.707
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleR

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 637, length: 1, timestamp: 291
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:36.892
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	apple

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 636, length: 1, timestamp: 292
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:33:55.594
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 703, length: 1, timestamp: 349
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:15.420
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 771, length: 1, timestamp: 407
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:18.460
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	andoir

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 777, length: 1, timestamp: 415
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:18.672
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	andoi

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 776, length: 1, timestamp: 416
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:18.820
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	ando

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 775, length: 1, timestamp: 417
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:18.952
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	and

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 774, length: 1, timestamp: 418
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:20.883
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	andrd

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 776, length: 1, timestamp: 422
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:21.024
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	andr

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 775, length: 1, timestamp: 423
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:25.907
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	androidReceiptHah

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 788, length: 1, timestamp: 438
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:26.064
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: String
		required: false
		default: null
	androidReceiptHa

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 787, length: 1, timestamp: 439
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:43.211
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: M
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 726, length: 6, timestamp: 486
text:>M<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:34:48.424
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 844, length: 1, timestamp: 492
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:15.006
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 631, length: 1, timestamp: 551
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:19.171
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	vendo
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 636, length: 1, timestamp: 558
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:19.328
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	vend
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 635, length: 1, timestamp: 559
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:19.493
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	ven
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 634, length: 1, timestamp: 560
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:19.658
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	ve
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 633, length: 1, timestamp: 561
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:19.831
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	v
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 632, length: 1, timestamp: 562
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:20.746
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 631, length: 1, timestamp: 563
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:26.944
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 645, length: 1, timestamp: 579
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:30.285
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 654, length: 1, timestamp: 587
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:40.678
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 702, length: 1, timestamp: 628
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:52.210
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	isProduc
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 710, length: 1, timestamp: 638
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:52.393
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	isProdu
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 709, length: 1, timestamp: 639
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:52.568
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	isProd
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 708, length: 1, timestamp: 640
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:52.739
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	isPro
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 707, length: 1, timestamp: 641
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:52.893
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	isPr
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 706, length: 1, timestamp: 642
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:53.056
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	isP
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 705, length: 1, timestamp: 643
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:53.218
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	is
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 704, length: 1, timestamp: 644
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:53.391
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	i
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 703, length: 1, timestamp: 645
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:35:54.328
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 702, length: 1, timestamp: 646
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:04.124
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false

	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 701, length: 1, timestamp: 647
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:26.036
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ u })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1148, length: 0, timestamp: 650
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:26.583
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ us })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1149, length: 0, timestamp: 651
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:26.809
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ use })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1150, length: 0, timestamp: 652
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:27.001
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1151, length: 0, timestamp: 653
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:27.263
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1152, length: 0, timestamp: 654
text:>:<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:27.401
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user:  })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1153, length: 0, timestamp: 655
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:27.646
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1154, length: 0, timestamp: 656
text:>1<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:28.086
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1155, length: 0, timestamp: 657
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:28.228
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1,  })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1156, length: 0, timestamp: 658
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:28.473
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, p })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1157, length: 0, timestamp: 659
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:28.687
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, pr })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1158, length: 0, timestamp: 660
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:28.776
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, pro })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1159, length: 0, timestamp: 661
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:28.901
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, prod })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1160, length: 0, timestamp: 662
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:29.041
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, produ })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1161, length: 0, timestamp: 663
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:29.191
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, produc })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1162, length: 0, timestamp: 664
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:29.273
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1163, length: 0, timestamp: 665
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:29.763
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1164, length: 0, timestamp: 666
text:>:<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:29.898
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product:  })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1165, length: 0, timestamp: 667
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:36:30.221
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1166, length: 0, timestamp: 668
text:>1<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:11.291
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	Aircrf
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2144, length: 1, timestamp: 10
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:11.438
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	Aircr
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2143, length: 1, timestamp: 11
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:15.183
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	AircraftPr
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2148, length: 1, timestamp: 18
text:><



!ENTRY org.apache.log4j 2 0 2012-09-26 13:37:24.951
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,585:3,586 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:26.574
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	AircraftProductAuthorizationAtemp
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2171, length: 1, timestamp: 43
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:26.748
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	AircraftProductAuthorizationAtem
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2170, length: 1, timestamp: 44
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:26.910
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	AircraftProductAuthorizationAte
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2169, length: 1, timestamp: 45
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:37:29.053
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	AircraftProductAuthorizationAt
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 2168, length: 1, timestamp: 46
text:><



!ENTRY org.apache.log4j 2 0 2012-09-26 13:37:34.279
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,244:3,245 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-26 13:37:40.437
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,243:3,244 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-26 13:37:55.322
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,183:3,184 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:26.225
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 3991, length: 1, timestamp: 78
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:28.741
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema -
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4034, length: 1, timestamp: 83
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:28.930
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema 
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4033, length: 1, timestamp: 84
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:33.370
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('')
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4043, length: 0, timestamp: 95
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:42.085
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttemptSchem
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4142, length: 1, timestamp: 110
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:42.239
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttemptSche
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4141, length: 1, timestamp: 111
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:42.390
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttemptSch
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4140, length: 1, timestamp: 112
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:42.553
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttemptSc
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4139, length: 1, timestamp: 113
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:42.703
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttemptS
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4138, length: 1, timestamp: 114
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:42.859
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttempt
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4137, length: 1, timestamp: 115
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:38:50.618
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [AircraftProductAuthorizationAttemptSchemaInternal] A reference to the AircraftProductAuthorizationAttempt model.
	###
	AircraftProductAuthorizationAttempt: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
		AircraftProductAuthorizationAttemptSchema = require('../schema/AircraftProductAuthorizationAttemptSchema')
		@AircraftProductAuthorizationAttempt = @connection.model('')
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 4158, length: 0, timestamp: 137
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:03.114
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftPAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2410, length: 0, timestamp: 2165
text:>P<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:03.349
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftPrAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2411, length: 0, timestamp: 2166
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:03.450
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2412, length: 0, timestamp: 2167
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:03.615
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProdAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2413, length: 0, timestamp: 2168
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:03.752
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProduAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2414, length: 0, timestamp: 2169
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:03.918
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProducAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2415, length: 0, timestamp: 2170
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:04.040
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProductAuthorization
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2416, length: 0, timestamp: 2171
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:09.530
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProductAuthorizationAtte
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2434, length: 1, timestamp: 2177
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:12.115
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProductAuthorizationAttempt()
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2438, length: 1, timestamp: 2182
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:40:50.585
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						attempt = new db.AircraftProductAuthorizationAttempt()
						attempt.user = user._id
						attempt.product = product._id
						attempt.attemptType = 'apple'
						attempt.
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2560, length: 1, timestamp: 2276
text:><



!ENTRY org.apache.log4j 2 0 2012-09-26 13:40:51.144
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,399:3,400 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-26 13:41:15.986
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,429:3,430 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:41:41.161
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2385, length: 205, timestamp: 2292
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:41:44.699
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2025, length: 1, timestamp: 2294
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:41:54.589
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2233, length: 1, timestamp: 2301
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:21.534
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 984, length: 1, timestamp: 670
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:23.968
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	gen

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 987, length: 1, timestamp: 675
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:24.139
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	ge

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 986, length: 1, timestamp: 676
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:24.303
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	g

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 985, length: 1, timestamp: 677
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:24.498
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 984, length: 1, timestamp: 678
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:25.708
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 984, length: 1, timestamp: 680
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:42:39.129
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 1031, length: 1, timestamp: 723
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:35.067
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 702, length: 1, timestamp: 765
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:51.962
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSuccessfull
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 722, length: 1, timestamp: 787
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.459
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSuccessful
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 721, length: 1, timestamp: 788
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.492
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSuccessfu
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 720, length: 1, timestamp: 789
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.524
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSuccessf
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 719, length: 1, timestamp: 790
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.560
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSuccess
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 718, length: 1, timestamp: 791
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.594
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSucces
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 717, length: 1, timestamp: 792
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.686
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSucce
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 716, length: 1, timestamp: 793
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.691
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSucc
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 715, length: 1, timestamp: 794
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.696
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSuc
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 714, length: 1, timestamp: 795
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.727
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedSu
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 713, length: 1, timestamp: 796
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.770
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completedS
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 712, length: 1, timestamp: 797
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.790
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	completed
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 711, length: 1, timestamp: 798
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.824
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	complete
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 710, length: 1, timestamp: 799
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.857
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	complet
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 709, length: 1, timestamp: 800
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.891
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	comple
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 708, length: 1, timestamp: 801
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.927
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	compl
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 707, length: 1, timestamp: 802
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:52.954
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	comp
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 706, length: 1, timestamp: 803
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:53.117
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	com
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 705, length: 1, timestamp: 804
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:53.284
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	co
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 704, length: 1, timestamp: 805
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:53.469
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	c
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 703, length: 1, timestamp: 806
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:43:54.182
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
Schema = mongoose.Schema
ObjectId = Schema.ObjectId

###
Schema representing a specific aircraft make and model. 
@example MongoDB Collection
  db.aircraft.models
@example MongoDB Indexes
  db.aircraft.models.ensureIndex({ name: 1, modelYear: 1 }, { unique: true })
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class AircraftProductAuthorizationAttemptSchemaInternal
	user: 
		type: ObjectId
		required: true
		ref: 'users'
	product:
		type: ObjectId
		required: true
		ref: 'products'
	attemptType:
		type: String
		required: true
		enum: ['apple', 'android']
	isReceiptValid:
		type: Boolean
		required: true
		default: false
	
	appleReceiptHash:
		type: String
		required: false
		default: null
	appleReceipt:
		type: Mixed
		required: false
		default: null
	androidReceiptHash:
		type: String
		required: false
		default: null
	androidReceipt:
		type: Mixed
		required: false
		default: null
	checklist:
		type: ObjectId
		required: false
		default: null
		ref: 'aircraft.checklists'

AircraftProductAuthorizationAttemptSchema = new Schema(new AircraftProductAuthorizationAttemptSchemaInternal())
AircraftProductAuthorizationAttemptSchema.index({ user: 1, product: 1 })
module.exports = AircraftProductAuthorizationAttemptSchema<<<
Document event: offset: 702, length: 1, timestamp: 807
text:><



!ENTRY org.apache.log4j 2 0 2012-09-26 13:44:27.350
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,451:3,452 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:33.549
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save(())
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2253, length: 0, timestamp: 2316
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:33.742
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((e))
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2254, length: 0, timestamp: 2317
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:33.992
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((er))
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2255, length: 0, timestamp: 2318
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:34.182
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err))
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2256, length: 0, timestamp: 2319
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:34.892
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err ))
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2257, length: 0, timestamp: 2320
text:> <



!ENTRY org.apache.log4j 2 0 2012-09-26 13:44:35.453
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,463:3,464 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:36.966
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err))
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2257, length: 1, timestamp: 2321
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:37.610
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) )
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2258, length: 0, timestamp: 2322
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:38.242
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -)
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2259, length: 0, timestamp: 2323
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:39.263
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) - )
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2260, length: 0, timestamp: 2324
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:39.640
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -)
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2260, length: 1, timestamp: 2325
text:><



!ENTRY org.apache.log4j 2 0 2012-09-26 13:44:40.198
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,464:3,465 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:40.326
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) ->)
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2260, length: 0, timestamp: 2326
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:41.087
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> )
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2261, length: 0, timestamp: 2327
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:41.799
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
					)
					@.validateReceipt(receiptData, (err, receipt) ->
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						if not receipt?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						
						
					)
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2262, length: 0, timestamp: 2328
text:>
						
					<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:44:48.787
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2285, length: 376, timestamp: 2329
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:43.862
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if 
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2801, length: 2, timestamp: 2365
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:48.352
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if recepi
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2807, length: 1, timestamp: 2373
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:48.522
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if recep
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2806, length: 1, timestamp: 2374
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:48.697
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if rece
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2805, length: 1, timestamp: 2375
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:49.874
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if recei
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2806, length: 1, timestamp: 2378
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:54.223
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if receipt.stats
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2814, length: 1, timestamp: 2388
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:45:54.290
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if receipt.stat
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2813, length: 1, timestamp: 2389
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:46:11.189
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if receipt.status == 0
								attempt.isReceiptValid = true
							
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2868, length: 1, timestamp: 2428
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:47:13.135
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if receipt.status == 0 and rece
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2829, length: 1, timestamp: 2477
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:47:40.575
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2788, length: 1, timestamp: 2535
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:47:44.382
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.rec
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2808, length: 1, timestamp: 2549
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:47:44.540
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.re
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2807, length: 1, timestamp: 2550
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:47:44.705
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.r
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2806, length: 1, timestamp: 2551
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:47:44.880
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 2805, length: 1, timestamp: 2552
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:15.505
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save(e)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3067, length: 0, timestamp: 2588
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:15.720
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save(er)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3068, length: 0, timestamp: 2589
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:15.872
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save(err)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3069, length: 0, timestamp: 2590
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:17.987
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save((err)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3067, length: 0, timestamp: 2591
text:>(<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:21.229
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) )
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3072, length: 0, timestamp: 2593
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:21.856
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) -)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3073, length: 0, timestamp: 2594
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:22.162
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3074, length: 0, timestamp: 2595
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:22.499
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3075, length: 0, timestamp: 2596
text:>
									
								<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:48:47.028
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3252, length: 1, timestamp: 2614
text:><



!ENTRY org.apache.log4j 2 0 2012-09-26 13:48:53.318
!MESSAGE csep.parser.Lexer  - Unexpected symbol [4,033:4,034 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:25.360
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save(e)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3004, length: 0, timestamp: 2672
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:25.534
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save(er)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3005, length: 0, timestamp: 2673
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:25.684
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save(err)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3006, length: 0, timestamp: 2674
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:26.381
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save(er)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3006, length: 1, timestamp: 2675
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:26.531
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save(e)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3005, length: 1, timestamp: 2676
text:><


