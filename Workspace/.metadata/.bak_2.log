!SESSION 2012-09-26 12:26:40.393 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -data C:\SourceControl\QRef\trunk\Workspace -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_1.log
Created Time: 2012-09-26 13:49:26.681

!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:26.681
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save()
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3004, length: 1, timestamp: 2677
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:27.672
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save(())
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3004, length: 0, timestamp: 2678
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:28.302
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((e))
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3005, length: 0, timestamp: 2679
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:28.551
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((er))
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3006, length: 0, timestamp: 2680
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:28.721
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err))
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3007, length: 0, timestamp: 2681
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:29.269
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) )
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3009, length: 0, timestamp: 2682
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:29.749
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) -)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3010, length: 0, timestamp: 2683
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:30.134
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3011, length: 0, timestamp: 2684
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:30.689
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3012, length: 0, timestamp: 2685
text:>
									
								<



!ENTRY org.apache.log4j 4 0 2012-09-26 13:49:44.657
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3189, length: 1, timestamp: 2689
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:13.603
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3657, length: 1, timestamp: 2691
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:16.085
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	clonec
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3663, length: 1, timestamp: 2699
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:16.245
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	clone
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3662, length: 1, timestamp: 2700
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:18.887
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneCheck
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3667, length: 1, timestamp: 2707
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:19.035
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChec
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3666, length: 1, timestamp: 2708
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:19.200
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChe
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3665, length: 1, timestamp: 2709
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:19.350
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneCh
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3664, length: 1, timestamp: 2710
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:19.646
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneC
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3663, length: 1, timestamp: 2711
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:20.457
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	clone
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3662, length: 1, timestamp: 2712
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:23.836
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneCheckLis
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3670, length: 1, timestamp: 2722
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:23.986
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneCheckLi
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3669, length: 1, timestamp: 2723
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:24.156
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneCheckL
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3668, length: 1, timestamp: 2724
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:24.320
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneCheck
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3667, length: 1, timestamp: 2725
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:27.177
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3671, length: 2, timestamp: 2731
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:29.063
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (c)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3674, length: 0, timestamp: 2735
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:29.245
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (ch)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3675, length: 0, timestamp: 2736
text:>h<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:29.360
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (che)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3676, length: 0, timestamp: 2737
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:29.677
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (chec)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3677, length: 0, timestamp: 2738
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:29.928
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (che)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3677, length: 1, timestamp: 2739
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:30.090
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (ch)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3676, length: 1, timestamp: 2740
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:30.258
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (c)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3675, length: 1, timestamp: 2741
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:30.438
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: ()
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3674, length: 1, timestamp: 2742
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:31.360
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (o)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3674, length: 0, timestamp: 2743
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:31.870
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oC)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3675, length: 0, timestamp: 2744
text:>C<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:32.113
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCh)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3676, length: 0, timestamp: 2745
text:>h<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:32.297
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChe)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3677, length: 0, timestamp: 2746
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:32.542
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChec)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3678, length: 0, timestamp: 2747
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:32.702
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheck)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3679, length: 0, timestamp: 2748
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:33.040
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckL)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3680, length: 0, timestamp: 2749
text:>L<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:33.285
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckLi)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3681, length: 0, timestamp: 2750
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:33.387
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckLis)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3682, length: 0, timestamp: 2751
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:33.580
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3683, length: 0, timestamp: 2752
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:34.607
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList,)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3684, length: 0, timestamp: 2753
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:34.728
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, )
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3685, length: 0, timestamp: 2754
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:39.281
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, u)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3686, length: 0, timestamp: 2755
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:39.445
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, us)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3687, length: 0, timestamp: 2756
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:39.726
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, use)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3688, length: 0, timestamp: 2757
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:39.999
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3689, length: 0, timestamp: 2758
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:41.231
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user,)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3690, length: 0, timestamp: 2759
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:41.378
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, )
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3691, length: 0, timestamp: 2760
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:44.178
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, c)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3692, length: 0, timestamp: 2761
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:44.438
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, ca)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3693, length: 0, timestamp: 2762
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:44.600
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, cal)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3694, length: 0, timestamp: 2763
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:44.758
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, call)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3695, length: 0, timestamp: 2764
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:44.953
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callb)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3696, length: 0, timestamp: 2765
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:45.095
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callba)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3697, length: 0, timestamp: 2766
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:45.310
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callbac)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3698, length: 0, timestamp: 2767
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:45.493
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3699, length: 0, timestamp: 2768
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:54.424
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRe
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3716, length: 1, timestamp: 2782
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:45:59.726
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3735, length: 1, timestamp: 2802
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:11.794
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nCheckL
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3747, length: 1, timestamp: 2812
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:11.949
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nCheck
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3746, length: 1, timestamp: 2813
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:14.680
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = d
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3754, length: 1, timestamp: 2823
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:14.835
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = 
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3753, length: 1, timestamp: 2824
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:22.153
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3778, length: 1, timestamp: 2850
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:52.478
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oCHeckl
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3813, length: 1, timestamp: 2880
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:52.617
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oCHeck
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3812, length: 1, timestamp: 2881
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:52.785
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oCHec
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3811, length: 1, timestamp: 2882
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:52.930
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oCHe
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3810, length: 1, timestamp: 2883
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:53.085
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oCH
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3809, length: 1, timestamp: 2884
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:53.278
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oC
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3808, length: 1, timestamp: 2885
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:46:58.132
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckList, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklis
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3815, length: 1, timestamp: 2894
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:47:01.179
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oCheckist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3680, length: 1, timestamp: 2896
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:47:01.479
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3680, length: 0, timestamp: 2897
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:47:36.600
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3903, length: 0, timestamp: 2979
text:>
		<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:47:46.370
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3936, length: 0, timestamp: 3009
text:>
		<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:48:07.874
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		nChecklis
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3949, length: 1, timestamp: 3020
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:48:09.030
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		nChecklist
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3950, length: 1, timestamp: 3023
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:48:16.033
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		nChecklist.user = user._id;
		
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3967, length: 0, timestamp: 3041
text:>
		<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:48:17.154
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		nChecklist.user = user._id;
	
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3970, length: 1, timestamp: 3042
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:48:17.382
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		nChecklist.user = user._id;

	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3969, length: 1, timestamp: 3043
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:48:17.598
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null;
		nChecklist.tailNumber = null;
		nChecklist.user = user._id;
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3967, length: 2, timestamp: 3044
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:18.223
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oCHeck
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4025, length: 1, timestamp: 3096
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:18.398
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oCHec
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4024, length: 1, timestamp: 3097
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:18.553
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oCHe
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4023, length: 1, timestamp: 3098
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:18.710
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oCH
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4022, length: 1, timestamp: 3099
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:18.890
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oC
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4021, length: 1, timestamp: 3100
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:39.750
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oCHe
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4072, length: 1, timestamp: 3132
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:39.911
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oCH
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4071, length: 1, timestamp: 3133
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:40.070
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oC
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4070, length: 1, timestamp: 3134
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:49:54.406
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.ta
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4126, length: 1, timestamp: 3181
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:20.901
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCHecklis
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4187, length: 1, timestamp: 3238
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:21.053
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCHeckli
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4186, length: 1, timestamp: 3239
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:21.213
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCHeckl
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4185, length: 1, timestamp: 3240
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:21.396
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCHeck
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4184, length: 1, timestamp: 3241
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:21.523
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCHec
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4183, length: 1, timestamp: 3242
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:21.708
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCHe
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4182, length: 1, timestamp: 3243
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:21.885
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nCH
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4181, length: 1, timestamp: 3244
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:22.683
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nC
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4180, length: 1, timestamp: 3245
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:58.065
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(c)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4281, length: 0, timestamp: 3320
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:58.337
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(ca)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4282, length: 0, timestamp: 3321
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:58.437
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(cal)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4283, length: 0, timestamp: 3322
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:58.617
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(call)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4284, length: 0, timestamp: 3323
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:58.833
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(callb)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4285, length: 0, timestamp: 3324
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:58.937
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(callba)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4286, length: 0, timestamp: 3325
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:59.147
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(callbac)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4287, length: 0, timestamp: 3326
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:50:59.250
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(callback)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4288, length: 0, timestamp: 3327
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:36.663
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save()
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4281, length: 8, timestamp: 3328
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:38.069
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(c)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4281, length: 0, timestamp: 3329
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:38.282
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(ch)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4282, length: 0, timestamp: 3330
text:>h<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:38.454
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(che)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4283, length: 0, timestamp: 3331
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:38.702
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(chec)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4284, length: 0, timestamp: 3332
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:38.864
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(check)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4285, length: 0, timestamp: 3333
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:39.012
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checkl)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4286, length: 0, timestamp: 3334
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:39.237
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checkli)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4287, length: 0, timestamp: 3335
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:39.374
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklis)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4288, length: 0, timestamp: 3336
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:39.549
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 4289, length: 0, timestamp: 3337
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:48.014
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3177, length: 1, timestamp: 3338
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:56.939
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									db
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3190, length: 1, timestamp: 3343
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:57.104
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									d
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3189, length: 1, timestamp: 3344
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:51:57.256
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3188, length: 1, timestamp: 3345
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:00.048
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3188, length: 1, timestamp: 3347
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:05.011
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = db
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3201, length: 1, timestamp: 3362
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:05.181
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = d
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3200, length: 1, timestamp: 3363
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:05.339
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = 
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3199, length: 1, timestamp: 3364
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:11.692
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3218, length: 1, timestamp: 3384
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:38.916
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.porduct
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3281, length: 1, timestamp: 3428
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:39.074
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.porduc
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3280, length: 1, timestamp: 3429
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:39.276
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.pordu
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3279, length: 1, timestamp: 3430
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:39.399
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.pord
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3278, length: 1, timestamp: 3431
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:39.554
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.por
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3277, length: 1, timestamp: 3432
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:39.727
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.po
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3276, length: 1, timestamp: 3433
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:40.891
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.p
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3275, length: 1, timestamp: 3434
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:51.976
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save(())
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3331, length: 0, timestamp: 3471
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:52.701
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((e))
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3332, length: 0, timestamp: 3472
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:52.961
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((er))
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3333, length: 0, timestamp: 3473
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:53.113
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err))
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3334, length: 0, timestamp: 3474
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:53.839
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) )
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3336, length: 0, timestamp: 3475
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:54.363
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3337, length: 0, timestamp: 3476
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:54.768
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) ->)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3338, length: 0, timestamp: 3477
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:54.953
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> )
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3339, length: 0, timestamp: 3478
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:52:55.328
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3340, length: 0, timestamp: 3479
text:>
										
									<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:14.384
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3524, length: 1, timestamp: 3494
text:><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:31.951
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(p)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3541, length: 0, timestamp: 3512
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:32.153
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(pr)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3542, length: 0, timestamp: 3513
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:32.273
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(pro)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3543, length: 0, timestamp: 3514
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:32.435
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(prod)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3544, length: 0, timestamp: 3515
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:32.883
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(produ)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3545, length: 0, timestamp: 3516
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:33.203
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(produc)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3546, length: 0, timestamp: 3517
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:33.363
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3547, length: 0, timestamp: 3518
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:34.000
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3548, length: 0, timestamp: 3519
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:34.423
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.a)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3549, length: 0, timestamp: 3520
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:34.571
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.ai)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3550, length: 0, timestamp: 3521
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:34.739
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.air)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3551, length: 0, timestamp: 3522
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:35.113
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.airc)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3552, length: 0, timestamp: 3523
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:35.338
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircr)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3553, length: 0, timestamp: 3524
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:35.561
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircra)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3554, length: 0, timestamp: 3525
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:35.700
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraf)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3555, length: 0, timestamp: 3526
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:35.868
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraft)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3556, length: 0, timestamp: 3527
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:36.573
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftC)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3557, length: 0, timestamp: 3528
text:>C<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:36.803
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftCh)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3558, length: 0, timestamp: 3529
text:>h<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:36.970
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChe)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3559, length: 0, timestamp: 3530
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:37.183
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChec)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3560, length: 0, timestamp: 3531
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:37.303
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftCheck)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3561, length: 0, timestamp: 3532
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:37.515
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftCheckl)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3562, length: 0, timestamp: 3533
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:37.793
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftCheckli)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3563, length: 0, timestamp: 3534
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:37.802
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklis)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3564, length: 0, timestamp: 3535
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:37.995
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3565, length: 0, timestamp: 3536
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:38.729
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist,)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3566, length: 0, timestamp: 3537
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:38.845
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, )
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3567, length: 0, timestamp: 3538
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:39.094
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, u)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3568, length: 0, timestamp: 3539
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:39.215
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, us)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3569, length: 0, timestamp: 3540
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:39.458
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, use)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3570, length: 0, timestamp: 3541
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:39.784
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3571, length: 0, timestamp: 3542
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:40.048
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user,)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3572, length: 0, timestamp: 3543
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:40.278
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, )
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3573, length: 0, timestamp: 3544
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:41.061
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, ())
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3574, length: 0, timestamp: 3545
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:41.573
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (e))
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3575, length: 0, timestamp: 3546
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:41.821
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (er))
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3576, length: 0, timestamp: 3547
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:42.042
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err))
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3577, length: 0, timestamp: 3548
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:42.816
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err) )
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3579, length: 0, timestamp: 3549
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:43.431
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err) -)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3580, length: 0, timestamp: 3550
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:43.768
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err) ->)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3581, length: 0, timestamp: 3551
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-26 15:53:44.160
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err) ->
											
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3582, length: 0, timestamp: 3552
text:>
											
										<



!ENTRY org.apache.log4j 4 0 2012-09-26 15:54:00.430
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../RpcRoute')
QRefDatabase = require('../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
###
Service route that performs authentication of Apple IAP Requests.
@example Service Methods (see {AuthorizeAppleProductRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/authorize/apple
    @BODY - (Required) AuthorizeAppleProductRpcRequest
    
  Performs apple IAP authorization and returns the handle to the user specific checklist if successful.
@author Nathan Klick
@copyright QRef 2012
###
class AuthorizeAppleAircraftProductRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/authorize/apple' }, { method: 'GET', path: '/product/authorize/apple' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		token = req.param('token')
		productId = req.body.product
		db = QRefDatabase.instance()
		receiptData = req.body.receipt
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new RpcResponse(null)
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			UserAuth.userFromToken(token, (err, user) -> 
				if err? or not user?
					resp = new RpcResponse(null)
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
					
				db.Product.findById(productId)
						.populate('aircraftChecklist')
						.exec((err, product) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					if not product?
						resp = new RpcResponse(null)
						resp.failure('Product Not Found', 404)
						res.json(resp, 200)
						return
						
					attempt = new db.AircraftProductAuthorizationAttempt()
					attempt.user = user._id
					attempt.product = product._id
					attempt.attemptType = 'apple'
					attempt.appleReceiptHash = receiptData
					
					attempt.save((err) -> 
						
						if err?
							resp = new RpcResponse(null)
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						@.validateReceipt(receiptData, (err, receipt) ->
							if err?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							if not receipt?
								resp = new RpcResponse(null)
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
							
							attempt.appleReceipt = receipt
								
							if receipt.status == 0 and receipt.receipt.product_id == product.appleProductIdentifier
								attempt.isReceiptValid = true
							
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
									
									uProduct = new db.UserProduct()
									uProduct.user = user._id
									uProduct.product = product._id
									
									uProduct.save((err) -> 
										if err?
											resp = new RpcResponse(null)
											resp.failure('Internal Error', 500)
											res.json(resp, 200)
											return
											
										@.cloneChecklist(product.aircraftChecklist, user, (err) ->
											if err?
												resp = new RpcResponse(null)
												resp.failure('Internal Error', 500)
												res.json(resp, 200)
												return
											
										)
									)
									
								)
							else
								attempt.isReceiptValid = false
								
								attempt.save((err) ->
									if err?
										resp = new RpcResponse(null)
										resp.failure('Internal Error', 500)
										res.json(resp, 200)
										return
										
									resp = new RpcResponse(null)
									resp.failure('Not Authorized', 403)
									res.json(resp, 200)
									return
								)
							
						)
					)
					
				)
			)
		)
	cloneChecklist: (oChecklist, user, callback) ->
		db = QRefDatabase.instance()
		nChecklist = new db.AircraftChecklist()
		
		nChecklist.model = oChecklist.model
		nChecklist.manufacturer = oChecklist.manufacturer
		nChecklist.index = null
		nChecklist.tailNumber = null
		nChecklist.user = user._id
		nChecklist.version = 1
		nChecklist.productIcon = oChecklist.productIcon
		nChecklist.preflight = oChecklist.preflight
		nChecklist.takeoff = oChecklist.takeoff
		nChecklist.landing = oChecklist.landing
		nChecklist.emergencies = oChecklist.emergencies
		nChecklist.isDeleted = false
		
		nChecklist.save(checklist)
	validateReceipt: (receiptData, callback) ->
		options =
			hostname: "buy.itunes.apple.com"
			port: 443
			path: "/verifyReceipt"
			method: "POST"
		
		request =
			receipt-data: receiptData
		
		requestData = JSON.stringify(request)
		
		data = ""
		
		req = https.request(options, (res) -> 
				res.setEncoding('ascii')
				
				res.on('data', (buff) ->
					data += buff
				)
				
				res.on('end', () ->
					if data? 
						response = JSON.parse(data)
						
						if not response?
							callback(new Error('Invalid JSON data received from server.'), null)
						else
							callback(null, response)
					else
						callback(new Error('No data received from the server.'), null)
				)
		)
		
		req.on('error', (err) ->
			callback(err, null)
		)
		
		req.write(requestData)
		req.end()
		
			
		
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.receipt?
			true
		else
			false
module.exports = new AuthorizeAppleAircraftProductRoute()<<<
Document event: offset: 3759, length: 1, timestamp: 3566
text:><


