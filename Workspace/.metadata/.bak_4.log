!SESSION 2012-09-19 12:15:53.765 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -data C:\SourceControl\QRef\trunk\Workspace -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_3.log
Created Time: 2012-09-19 14:28:07.679

!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:07.680
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ rfor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9135, length: 0, timestamp: 1101
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:07.891
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ rofor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9136, length: 0, timestamp: 1102
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:08.126
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ rolfor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9137, length: 0, timestamp: 1103
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:08.231
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ rolefor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9138, length: 0, timestamp: 1104
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:08.654
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleNfor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9139, length: 0, timestamp: 1105
text:>N<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:08.821
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleNafor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9140, length: 0, timestamp: 1106
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:08.918
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleNamfor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9141, length: 0, timestamp: 1107
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:09.076
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleNamefor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9142, length: 0, timestamp: 1108
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:09.548
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName:for r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9143, length: 0, timestamp: 1109
text:>:<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:09.796
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: for r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9144, length: 0, timestamp: 1110
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:10.855
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: rfor r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9145, length: 0, timestamp: 1111
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:11.684
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r for r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9146, length: 0, timestamp: 1112
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:11.969
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }for r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9147, length: 0, timestamp: 1113
text:>}<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:13.781
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r })for r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9148, length: 0, timestamp: 1114
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:28:14.479
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9149, length: 0, timestamp: 1115
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:30.102
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9187, length: 62, timestamp: 1116
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:31.149
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role
							(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9187, length: 0, timestamp: 1117
text:>
							<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:37.997
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ ""}
							(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9195, length: 0, timestamp: 1126
text:>""<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:38.317
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$"}
							(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9196, length: 0, timestamp: 1127
text:>$<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:38.663
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$o"}
							(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9197, length: 0, timestamp: 1128
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:38.768
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or"}
							(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9198, length: 0, timestamp: 1129
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:47.597
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9219, length: 0, timestamp: 1148
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:53.892
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec(						(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1159
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:54.204
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec(					(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1160
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:54.409
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec(				(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1161
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:54.608
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec(			(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1162
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:54.825
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec(		(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1163
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:55.050
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec(	(err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1164
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:55.292
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
								.exec((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9236, length: 1, timestamp: 1165
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:29:58.464
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9229, length: 1, timestamp: 1166
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:05.806
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, a) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9241, length: 4, timestamp: 1167
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:06.082
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, ar) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9242, length: 0, timestamp: 1168
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:06.219
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arr) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9243, length: 0, timestamp: 1169
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:06.736
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrR) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9244, length: 0, timestamp: 1170
text:>R<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:06.956
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRo) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9245, length: 0, timestamp: 1171
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:07.170
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRol) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9246, length: 0, timestamp: 1172
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:07.242
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRole) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9247, length: 0, timestamp: 1173
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:07.497
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9248, length: 0, timestamp: 1174
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:14.526
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not role
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9349, length: 1, timestamp: 1175
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:14.673
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not rol
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9348, length: 1, timestamp: 1176
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:14.830
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not ro
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9347, length: 1, timestamp: 1177
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:14.985
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not r
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9346, length: 1, timestamp: 1178
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:15.134
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not 
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9345, length: 1, timestamp: 1179
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:15.299
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if not
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9344, length: 1, timestamp: 1180
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:15.450
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if no
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9343, length: 1, timestamp: 1181
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:15.803
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if n
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9342, length: 1, timestamp: 1182
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:15.976
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if 
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9341, length: 1, timestamp: 1183
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:31.971
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								c
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9455, length: 1, timestamp: 1207
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:32.101
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9454, length: 1, timestamp: 1208
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:30:42.733
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9483, length: 1, timestamp: 1238
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:02.541
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9520, length: 0, timestamp: 1257
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:03.366
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r.)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9521, length: 0, timestamp: 1258
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:04.575
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9522, length: 0, timestamp: 1259
text:>_<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:05.231
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._i)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9523, length: 0, timestamp: 1260
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:05.337
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9524, length: 0, timestamp: 1261
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:05.753
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id,)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9525, length: 0, timestamp: 1262
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:05.926
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, )
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9526, length: 0, timestamp: 1263
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:06.247
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9527, length: 0, timestamp: 1264
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:06.565
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9528, length: 0, timestamp: 1265
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:06.973
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.r)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9529, length: 0, timestamp: 1266
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:07.267
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.ro)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9530, length: 0, timestamp: 1267
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:07.476
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.rol)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9531, length: 0, timestamp: 1268
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:07.531
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.role)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9532, length: 0, timestamp: 1269
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:07.951
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.roleN)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9533, length: 0, timestamp: 1270
text:>N<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:08.134
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.roleNa)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9534, length: 0, timestamp: 1271
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:08.237
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.roleNam)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9535, length: 0, timestamp: 1272
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:08.374
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id, r.roleName)
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9536, length: 0, timestamp: 1273
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:42.860
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id., r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9525, length: 0, timestamp: 1293
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:43.145
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.t, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9526, length: 0, timestamp: 1294
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:43.288
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.to, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9527, length: 0, timestamp: 1295
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:43.722
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toS, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9528, length: 0, timestamp: 1296
text:>S<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:43.844
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toSt, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9529, length: 0, timestamp: 1297
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:43.974
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toStr, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9530, length: 0, timestamp: 1298
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:44.259
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toStri, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9531, length: 0, timestamp: 1299
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:44.402
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toStrin, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9532, length: 0, timestamp: 1300
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:44.483
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString, r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9533, length: 0, timestamp: 1301
text:>g<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:45.045
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9534, length: 0, timestamp: 1302
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:31:45.255
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9535, length: 1, timestamp: 1303
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:18.031
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if d
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9665, length: 38, timestamp: 1304
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:22.084
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.cona
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9681, length: 1, timestamp: 1321
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:22.221
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.con
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9680, length: 1, timestamp: 1322
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:26.348
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(i)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9689, length: 0, timestamp: 1332
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:26.641
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(it)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9690, length: 0, timestamp: 1333
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:26.781
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(ite)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9691, length: 0, timestamp: 1334
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:26.989
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(ite,)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9692, length: 0, timestamp: 1335
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:27.334
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(ite,.)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9693, length: 0, timestamp: 1336
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:28.368
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(ite,)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9693, length: 1, timestamp: 1337
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:28.527
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(ite)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9692, length: 1, timestamp: 1338
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:28.863
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9692, length: 0, timestamp: 1339
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:29.290
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9693, length: 0, timestamp: 1340
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:29.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.t)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9694, length: 0, timestamp: 1341
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:29.861
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.to)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9695, length: 0, timestamp: 1342
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:30.238
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toS)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9696, length: 0, timestamp: 1343
text:>S<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:30.399
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toSt)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9697, length: 0, timestamp: 1344
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:30.500
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toStr)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9698, length: 0, timestamp: 1345
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:30.766
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toStri)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9699, length: 0, timestamp: 1346
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:30.934
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toStrin)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9700, length: 0, timestamp: 1347
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:31.035
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString)
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9701, length: 0, timestamp: 1348
text:>g<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:31.543
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9702, length: 0, timestamp: 1349
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:32:31.885
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 9703, length: 1, timestamp: 1350
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:02.778
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.findOn
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6038, length: 1, timestamp: 1392
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:02.927
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.findO
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6037, length: 1, timestamp: 1393
text:><


