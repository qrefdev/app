!SESSION 2012-09-19 12:15:53.765 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -data C:\SourceControl\QRef\trunk\Workspace -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_4.log
Created Time: 2012-09-19 14:39:03.097

!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:03.098
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.find
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6036, length: 1, timestamp: 1394
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:03.263
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.fin
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6035, length: 1, timestamp: 1395
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:03.419
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.fi
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6034, length: 1, timestamp: 1396
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:03.579
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.f
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6033, length: 1, timestamp: 1397
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:03.737
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6032, length: 1, timestamp: 1398
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:06.817
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('')
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6038, length: 0, timestamp: 1405
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:14.796
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('')
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6063, length: 0, timestamp: 1427
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:21.232
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne(())
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6086, length: 0, timestamp: 1443
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:22.401
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((e))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6087, length: 0, timestamp: 1444
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:22.637
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((er))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6088, length: 0, timestamp: 1445
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:22.825
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6089, length: 0, timestamp: 1446
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:22.965
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err,))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6090, length: 0, timestamp: 1447
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:23.265
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, ))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6091, length: 0, timestamp: 1448
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:24.765
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, r))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6092, length: 0, timestamp: 1449
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:25.036
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, ro))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6093, length: 0, timestamp: 1450
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:25.256
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, rol))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6094, length: 0, timestamp: 1451
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:25.327
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role))
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6095, length: 0, timestamp: 1452
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:26.115
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) )
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6097, length: 0, timestamp: 1453
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:26.468
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) -)
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6098, length: 0, timestamp: 1454
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:26.855
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->)
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6099, length: 0, timestamp: 1455
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:27.229
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
				)
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6100, length: 0, timestamp: 1456
text:>
					
				<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:39:34.300
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6118, length: 553, timestamp: 1457
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:02.492
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(e)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6138, length: 0, timestamp: 1551
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:02.718
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(er)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6139, length: 0, timestamp: 1552
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:02.887
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6140, length: 0, timestamp: 1553
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:03.162
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err,)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6141, length: 0, timestamp: 1554
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:03.364
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, )
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6142, length: 0, timestamp: 1555
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:03.687
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, f)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6143, length: 0, timestamp: 1556
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:03.929
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, fa)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6144, length: 0, timestamp: 1557
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:04.121
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, fal)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6145, length: 0, timestamp: 1558
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:04.292
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, fals)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6146, length: 0, timestamp: 1559
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:04.501
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6147, length: 0, timestamp: 1560
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:04.634
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false,)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6148, length: 0, timestamp: 1561
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:04.878
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, )
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6149, length: 0, timestamp: 1562
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:08.203
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6150, length: 0, timestamp: 1563
text:>4<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:11.573
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6173, length: 1, timestamp: 1572
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:17.681
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6200, length: 1, timestamp: 1588
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:19.775
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(e)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6209, length: 0, timestamp: 1598
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:20.021
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(er)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6210, length: 0, timestamp: 1599
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:20.175
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6211, length: 0, timestamp: 1600
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:20.351
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err,)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6212, length: 0, timestamp: 1601
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:20.508
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, )
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6213, length: 0, timestamp: 1602
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:20.751
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, f)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6214, length: 0, timestamp: 1603
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:20.993
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, fa)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6215, length: 0, timestamp: 1604
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:21.060
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, fal)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6216, length: 0, timestamp: 1605
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:21.188
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, fals)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6217, length: 0, timestamp: 1606
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:21.391
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6218, length: 0, timestamp: 1607
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:21.790
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false )
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6219, length: 0, timestamp: 1608
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:21.799
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false ,)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6220, length: 0, timestamp: 1609
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:22.403
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false ,5)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6221, length: 0, timestamp: 1610
text:>5<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:23.364
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false , 5)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6221, length: 0, timestamp: 1611
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:24.212
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6219, length: 1, timestamp: 1612
text:><



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:35.794
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(r)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6456, length: 0, timestamp: 1637
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:36.038
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(ro)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6457, length: 0, timestamp: 1638
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:36.251
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(rol)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6458, length: 0, timestamp: 1639
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:36.307
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6459, length: 0, timestamp: 1640
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:37.371
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role.)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6460, length: 0, timestamp: 1641
text:>.<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:37.688
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role._)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6461, length: 0, timestamp: 1642
text:>_<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:38.001
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role._i)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6462, length: 0, timestamp: 1643
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-19 14:40:38.089
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role._id)
					
					db.User.where('userName')
							.equals(userName)
							.find((err, arrObjs) ->
								if err?
									callback(err, false, 1)
									return
								if arrObjs? and arrObjs.length > 0
									callback(null, false, 2)
									return
								else
									user.save((err) ->
										if err?
											callback(err, false, 3)
										else
											callback(null, true, 0)
									)
								
							)
				)
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
						
						db.Role.where('roleName')
							.equals(roleName)
							.findOne((err, role) ->
								if err?
									callback(err, false)
									return
								
								if not role?
									callback(null, false)
									return
								
								bFound = false
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if item.toString() == role._id.toString()
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) -> 
						
						if err?
							callback(err, false);
							return
							
						if not tk?
							callback(null, false);	
							return
							
						arrQueryEntries = []
						
						arrQueryEntries.push({ roleName: r }) for r in roles
						
						db.Role.find({ "$or": arrQueryEntries })
							.exec((err, arrRoles) ->
								if err?
									callback(err, false)
									return
								
								if arrRoles.length == 0
									callback(null, false)
									return
								
								bFound = false
								dctRoleKeys = new Dictionary()
								
								dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
								
								
								async.forEach(tk.user.roles, 
									(item, cb) ->
										if dctRoleKeys.containsKey(item.toString())
											bFound = true
										cb(null)
									, (err) ->
										callback(null, bFound)
								)
							)
					)
module.exports = new UserAuth()<<<
Document event: offset: 6463, length: 0, timestamp: 1644
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:11.728
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: ()<<<
Document event: offset: 35, length: 1, timestamp: 35
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:14.079
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	<<<
Document event: offset: 42, length: 1, timestamp: 40
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:43.508
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter <<<
Document event: offset: 49, length: 2, timestamp: 49
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:43.676
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter<<<
Document event: offset: 48, length: 1, timestamp: 50
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:49.338
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (r)<<<
Document event: offset: 51, length: 0, timestamp: 54
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:49.597
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (re)<<<
Document event: offset: 52, length: 0, timestamp: 55
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:49.911
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (rec)<<<
Document event: offset: 53, length: 0, timestamp: 56
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:50.125
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (reco)<<<
Document event: offset: 54, length: 0, timestamp: 57
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:50.325
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (recor)<<<
Document event: offset: 55, length: 0, timestamp: 58
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:50.688
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (record)<<<
Document event: offset: 56, length: 0, timestamp: 59
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:51.251
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (recor)<<<
Document event: offset: 56, length: 1, timestamp: 60
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:51.427
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (reco)<<<
Document event: offset: 55, length: 1, timestamp: 61
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:51.584
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (rec)<<<
Document event: offset: 54, length: 1, timestamp: 62
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:51.755
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (re)<<<
Document event: offset: 53, length: 1, timestamp: 63
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:51.919
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (r)<<<
Document event: offset: 52, length: 1, timestamp: 64
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:52.064
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: ()<<<
Document event: offset: 51, length: 1, timestamp: 65
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:52.269
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (a)<<<
Document event: offset: 51, length: 0, timestamp: 66
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:52.691
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (ar)<<<
Document event: offset: 52, length: 0, timestamp: 67
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:52.740
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arr)<<<
Document event: offset: 53, length: 0, timestamp: 68
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:53.112
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrR)<<<
Document event: offset: 54, length: 0, timestamp: 69
text:>R<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:53.343
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRe)<<<
Document event: offset: 55, length: 0, timestamp: 70
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:53.620
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRec)<<<
Document event: offset: 56, length: 0, timestamp: 71
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:53.804
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrReco)<<<
Document event: offset: 57, length: 0, timestamp: 72
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:53.985
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecor)<<<
Document event: offset: 58, length: 0, timestamp: 73
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:54.266
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecord)<<<
Document event: offset: 59, length: 0, timestamp: 74
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:54.565
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords)<<<
Document event: offset: 60, length: 0, timestamp: 75
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:55.569
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords,)<<<
Document event: offset: 61, length: 0, timestamp: 76
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:55.692
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, )<<<
Document event: offset: 62, length: 0, timestamp: 77
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:56.067
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, c)<<<
Document event: offset: 63, length: 0, timestamp: 78
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:56.307
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, ca)<<<
Document event: offset: 64, length: 0, timestamp: 79
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:56.460
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, cal)<<<
Document event: offset: 65, length: 0, timestamp: 80
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:56.727
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, call)<<<
Document event: offset: 66, length: 0, timestamp: 81
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:56.857
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, callb)<<<
Document event: offset: 67, length: 0, timestamp: 82
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:56.936
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, callba)<<<
Document event: offset: 68, length: 0, timestamp: 83
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:57.221
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, callbac)<<<
Document event: offset: 69, length: 0, timestamp: 84
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:29:57.350
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>class RecordFilter
	constructor: () ->
	filter: (arrRecords, callback)<<<
Document event: offset: 70, length: 0, timestamp: 85
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:19.013
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 104, length: 1, timestamp: 114
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:26.919
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	
		filter: (arrRecords, callback) ->
	<<<
Document event: offset: 68, length: 0, timestamp: 115
text:>
		<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:27.875
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 71, length: 1, timestamp: 116
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:47.720
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setUser:
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 76, length: 1, timestamp: 126
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:47.905
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setUser
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 75, length: 1, timestamp: 127
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:48.123
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setUse
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 74, length: 1, timestamp: 128
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:48.500
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setUs
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 73, length: 1, timestamp: 129
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:48.778
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setU
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 72, length: 1, timestamp: 130
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:48.857
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	set
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 71, length: 1, timestamp: 131
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:49.130
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	se
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 70, length: 1, timestamp: 132
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:49.317
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	s
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 69, length: 1, timestamp: 133
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:30:49.468
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 68, length: 1, timestamp: 134
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:21.430
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContet: ()
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 84, length: 1, timestamp: 156
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:21.554
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: ()
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 84, length: 0, timestamp: 157
text:>x<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:31.147
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (u)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 89, length: 0, timestamp: 158
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:31.337
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (us)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 90, length: 0, timestamp: 159
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:31.654
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (use)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 91, length: 0, timestamp: 160
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:31.900
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 92, length: 0, timestamp: 161
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:33.139
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user,)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 93, length: 0, timestamp: 162
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:33.363
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, )
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 94, length: 0, timestamp: 163
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:34.167
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, t)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 95, length: 0, timestamp: 164
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:34.440
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, to)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 96, length: 0, timestamp: 165
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:34.687
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, tok)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 97, length: 0, timestamp: 166
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:34.809
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, toke)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 98, length: 0, timestamp: 167
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:35.002
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 99, length: 0, timestamp: 168
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:35.438
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token,)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 100, length: 0, timestamp: 169
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:35.648
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token, )
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 101, length: 0, timestamp: 170
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:36.425
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token, r)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 102, length: 0, timestamp: 171
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:36.633
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token, ro)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 103, length: 0, timestamp: 172
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:36.855
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token, rol)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 104, length: 0, timestamp: 173
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:36.925
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token, role)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 105, length: 0, timestamp: 174
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:37.178
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	constructor: () ->
	setSecurityContext: (user, token, roles)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 106, length: 0, timestamp: 175
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:43.262
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	
		constructor: () ->
	setSecurityContext: (user, token, roles) ->
		
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 47, length: 0, timestamp: 180
text:>
		<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:43.981
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	
	constructor: () ->
	setSecurityContext: (user, token, roles) ->
		
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 50, length: 1, timestamp: 181
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:52.511
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token
	constructor: () ->
	setSecurityContext: (user, token, roles) ->
		
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 65, length: 1, timestamp: 199
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:31:57.776
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
	setSecurityContext: (user, token, roles) ->
		
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 82, length: 1, timestamp: 215
text:>]<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:07.900
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, roles) ->
	
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 169, length: 1, timestamp: 229
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.344
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, roles) ->

	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 168, length: 1, timestamp: 230
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.392
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, roles) -
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 165, length: 1, timestamp: 232
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.416
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, roles) 
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 164, length: 1, timestamp: 233
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.441
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, roles)
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 163, length: 1, timestamp: 234
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.465
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, roles
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 162, length: 1, timestamp: 235
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.488
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, role
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 161, length: 1, timestamp: 236
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.513
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, rol
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 160, length: 1, timestamp: 237
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.537
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, ro
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 159, length: 1, timestamp: 238
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.561
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, r
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 158, length: 1, timestamp: 239
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.587
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token, 
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 157, length: 1, timestamp: 240
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.615
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token,
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 156, length: 1, timestamp: 241
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.634
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 155, length: 1, timestamp: 242
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.658
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, toke
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 154, length: 1, timestamp: 243
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.682
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, tok
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 153, length: 1, timestamp: 244
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.706
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, to
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 152, length: 1, timestamp: 245
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.731
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, t
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 151, length: 1, timestamp: 246
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.755
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user, 
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 150, length: 1, timestamp: 247
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.780
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user,
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 149, length: 1, timestamp: 248
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.804
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 148, length: 1, timestamp: 249
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.828
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (use
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 147, length: 1, timestamp: 250
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.852
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (us
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 146, length: 1, timestamp: 251
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.877
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (u
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 145, length: 1, timestamp: 252
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.901
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: (
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 144, length: 1, timestamp: 253
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.925
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext: 
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 143, length: 1, timestamp: 254
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.949
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext:
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 142, length: 1, timestamp: 255
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.973
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContext
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 141, length: 1, timestamp: 256
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:08.997
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityContex
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 140, length: 1, timestamp: 257
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.021
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityConte
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 139, length: 1, timestamp: 258
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.046
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityCont
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 138, length: 1, timestamp: 259
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.070
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityCon
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 137, length: 1, timestamp: 260
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.094
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityCo
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 136, length: 1, timestamp: 261
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.118
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurityC
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 135, length: 1, timestamp: 262
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.142
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurity
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 134, length: 1, timestamp: 263
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.166
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecurit
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 133, length: 1, timestamp: 264
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.191
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecuri
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 132, length: 1, timestamp: 265
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.215
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecur
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 131, length: 1, timestamp: 266
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.239
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSecu
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 130, length: 1, timestamp: 267
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.264
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSec
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 129, length: 1, timestamp: 268
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.440
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setSe
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 128, length: 1, timestamp: 269
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.613
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	setS
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 127, length: 1, timestamp: 270
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.782
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	set
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 126, length: 1, timestamp: 271
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:09.975
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	se
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 125, length: 1, timestamp: 272
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:10.140
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	s
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 124, length: 1, timestamp: 273
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:10.332
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null
	
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 123, length: 1, timestamp: 274
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:10.520
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = null

	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 122, length: 1, timestamp: 275
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:14.470
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = nul
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 119, length: 1, timestamp: 277
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:14.631
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = nu
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 118, length: 1, timestamp: 278
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:14.770
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = n
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 117, length: 1, timestamp: 279
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:14.931
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: () ->
		@user = 
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 116, length: 1, timestamp: 280
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:17.405
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (u) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 100, length: 0, timestamp: 285
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:17.504
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (us) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 101, length: 0, timestamp: 286
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:17.760
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (use) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 102, length: 0, timestamp: 287
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:17.972
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 103, length: 0, timestamp: 288
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:18.829
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user,) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 104, length: 0, timestamp: 289
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:18.974
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user, ) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 105, length: 0, timestamp: 290
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:19.263
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user, r) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 106, length: 0, timestamp: 291
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:19.455
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user, ro) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 107, length: 0, timestamp: 292
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:19.693
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user, rol) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 108, length: 0, timestamp: 293
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:19.782
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user, role) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 109, length: 0, timestamp: 294
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:20.029
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (user, roles) ->
		@user = user
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 110, length: 0, timestamp: 295
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:41.374
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (tuser, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 100, length: 0, timestamp: 326
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:41.554
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (touser, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 101, length: 0, timestamp: 327
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:41.770
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (tokuser, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 102, length: 0, timestamp: 328
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:41.887
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (tokeuser, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 103, length: 0, timestamp: 329
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:42.019
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (tokenuser, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 104, length: 0, timestamp: 330
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:42.358
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token,user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 105, length: 0, timestamp: 331
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:32:42.495
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 106, length: 0, timestamp: 332
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:07.177
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	<<<
Document event: offset: 213, length: 1, timestamp: 334
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:14.368
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (r)<<<
Document event: offset: 229, length: 0, timestamp: 351
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:14.609
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (re)<<<
Document event: offset: 230, length: 0, timestamp: 352
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:14.868
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (rec)<<<
Document event: offset: 231, length: 0, timestamp: 353
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:14.982
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (reco)<<<
Document event: offset: 232, length: 0, timestamp: 354
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:15.171
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (recor)<<<
Document event: offset: 233, length: 0, timestamp: 355
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:15.407
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record)<<<
Document event: offset: 234, length: 0, timestamp: 356
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:15.723
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record,)<<<
Document event: offset: 235, length: 0, timestamp: 357
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:15.951
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, )<<<
Document event: offset: 236, length: 0, timestamp: 358
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:16.491
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, c)<<<
Document event: offset: 237, length: 0, timestamp: 359
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:17.078
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, ca)<<<
Document event: offset: 238, length: 0, timestamp: 360
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:17.252
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, cal)<<<
Document event: offset: 239, length: 0, timestamp: 361
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:17.411
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, call)<<<
Document event: offset: 240, length: 0, timestamp: 362
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:17.650
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, callb)<<<
Document event: offset: 241, length: 0, timestamp: 363
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:17.772
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, callba)<<<
Document event: offset: 242, length: 0, timestamp: 364
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:18.014
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, callbac)<<<
Document event: offset: 243, length: 0, timestamp: 365
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:18.134
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	processRecord: (record, callback)<<<
Document event: offset: 244, length: 0, timestamp: 366
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:32.766
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	procesRecord: (record, callback) -><<<
Document event: offset: 219, length: 1, timestamp: 370
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:32.930
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	proceRecord: (record, callback) -><<<
Document event: offset: 218, length: 1, timestamp: 371
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:33.075
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	procRecord: (record, callback) -><<<
Document event: offset: 217, length: 1, timestamp: 372
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:33.245
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	proRecord: (record, callback) -><<<
Document event: offset: 216, length: 1, timestamp: 373
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:33.396
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	prRecord: (record, callback) -><<<
Document event: offset: 215, length: 1, timestamp: 374
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:33.536
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	pRecord: (record, callback) -><<<
Document event: offset: 214, length: 1, timestamp: 375
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:33.689
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	Record: (record, callback) -><<<
Document event: offset: 213, length: 1, timestamp: 376
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:34.315
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	fRecord: (record, callback) -><<<
Document event: offset: 213, length: 0, timestamp: 377
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:34.495
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	fiRecord: (record, callback) -><<<
Document event: offset: 214, length: 0, timestamp: 378
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:34.632
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	filRecord: (record, callback) -><<<
Document event: offset: 215, length: 0, timestamp: 379
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:34.910
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	filtRecord: (record, callback) -><<<
Document event: offset: 216, length: 0, timestamp: 380
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:35.037
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	filteRecord: (record, callback) -><<<
Document event: offset: 217, length: 0, timestamp: 381
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:33:35.261
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
	filterRecord: (record, callback) -><<<
Document event: offset: 218, length: 0, timestamp: 382
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:12.299
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(a)
	filterRecord: (record, callback) -><<<
Document event: offset: 228, length: 0, timestamp: 398
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:12.594
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(ar)
	filterRecord: (record, callback) -><<<
Document event: offset: 229, length: 0, timestamp: 399
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:12.741
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arr)
	filterRecord: (record, callback) -><<<
Document event: offset: 230, length: 0, timestamp: 400
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:13.174
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrR)
	filterRecord: (record, callback) -><<<
Document event: offset: 231, length: 0, timestamp: 401
text:>R<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:13.495
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRe)
	filterRecord: (record, callback) -><<<
Document event: offset: 232, length: 0, timestamp: 402
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:13.767
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRec)
	filterRecord: (record, callback) -><<<
Document event: offset: 233, length: 0, timestamp: 403
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:13.928
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrReco)
	filterRecord: (record, callback) -><<<
Document event: offset: 234, length: 0, timestamp: 404
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:14.103
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecor)
	filterRecord: (record, callback) -><<<
Document event: offset: 235, length: 0, timestamp: 405
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:14.397
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecord)
	filterRecord: (record, callback) -><<<
Document event: offset: 236, length: 0, timestamp: 406
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:14.680
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords)
	filterRecord: (record, callback) -><<<
Document event: offset: 237, length: 0, timestamp: 407
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:15.794
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,)
	filterRecord: (record, callback) -><<<
Document event: offset: 238, length: 0, timestamp: 408
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:17.089
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 239, length: 0, timestamp: 409
text:>
			
		<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:23.630
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(i)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 245, length: 0, timestamp: 411
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:23.906
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(it)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 246, length: 0, timestamp: 412
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:23.999
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(ite)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 247, length: 0, timestamp: 413
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:24.214
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(item)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 248, length: 0, timestamp: 414
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:24.499
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(item,)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 249, length: 0, timestamp: 415
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:24.827
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(item, )
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 250, length: 0, timestamp: 416
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:25.282
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(item, c)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 251, length: 0, timestamp: 417
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:25.458
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		async.forEach(arrRecords,
			(item, cb)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 252, length: 0, timestamp: 418
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:46.286
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		
		async.forEach(arrRecords,
			(item, cb) ->
				
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 214, length: 0, timestamp: 423
text:>
		<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:34:52.815
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) ->
				
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 236, length: 1, timestamp: 446
text:>]<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:14.661
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) ->
				@
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 291, length: 1, timestamp: 449
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:14.854
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) ->
				
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 290, length: 1, timestamp: 450
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:17.716
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) >
				
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 282, length: 1, timestamp: 451
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:17.990
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 282, length: 0, timestamp: 452
text:>=<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:29.835
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(i)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 305, length: 0, timestamp: 468
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:30.070
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(it)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 306, length: 0, timestamp: 469
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:30.201
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(ite)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 307, length: 0, timestamp: 470
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:30.448
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 308, length: 0, timestamp: 471
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:31.630
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item,)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 309, length: 0, timestamp: 472
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:31.774
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, )
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 310, length: 0, timestamp: 473
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:32.472
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 311, length: 0, timestamp: 474
text:>
					
				<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:36.025
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(e)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 319, length: 0, timestamp: 476
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:36.302
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(er)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 320, length: 0, timestamp: 477
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:36.491
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 321, length: 0, timestamp: 478
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:36.722
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err,)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 322, length: 0, timestamp: 479
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:37.057
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, )
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 323, length: 0, timestamp: 480
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:39.290
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, i)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 324, length: 0, timestamp: 481
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:39.517
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, in)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 325, length: 0, timestamp: 482
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:39.642
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, inc)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 326, length: 0, timestamp: 483
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:39.819
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, incl)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 327, length: 0, timestamp: 484
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:40.111
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, inclu)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 328, length: 0, timestamp: 485
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:40.209
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, includ)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 329, length: 0, timestamp: 486
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:40.477
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 330, length: 0, timestamp: 487
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:49.909
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(E)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 362, length: 0, timestamp: 503
text:>E<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:50.171
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(Er)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 363, length: 0, timestamp: 504
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:50.373
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(Err)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 364, length: 0, timestamp: 505
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:50.910
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(Er)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 364, length: 1, timestamp: 506
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:51.081
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(E)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 363, length: 1, timestamp: 507
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:51.318
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb()
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 362, length: 1, timestamp: 508
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:51.504
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(e)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 362, length: 0, timestamp: 509
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:51.836
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(er)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 363, length: 0, timestamp: 510
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:52.009
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 364, length: 0, timestamp: 511
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:35:55.728
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
							return
						
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 389, length: 1, timestamp: 520
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:14.613
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(i)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 440, length: 0, timestamp: 557
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:14.862
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(it)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 441, length: 0, timestamp: 558
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:15.068
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(ite)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 442, length: 0, timestamp: 559
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:15.315
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 443, length: 0, timestamp: 560
text:>m<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:17.031
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 444, length: 1, timestamp: 561
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:29.891
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include,) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 331, length: 0, timestamp: 562
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:30.061
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, ) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 332, length: 0, timestamp: 563
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:30.307
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, r) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 333, length: 0, timestamp: 564
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:30.518
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, re) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 334, length: 0, timestamp: 565
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:30.773
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 335, length: 0, timestamp: 566
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:30.956
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, reco) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 336, length: 0, timestamp: 567
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:31.092
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, recor) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 337, length: 0, timestamp: 568
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:31.346
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, record) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 338, length: 0, timestamp: 569
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:32.500
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, recor) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 338, length: 1, timestamp: 570
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:32.684
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, reco) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 337, length: 1, timestamp: 571
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:32.825
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 336, length: 1, timestamp: 572
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:32.984
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, re) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 335, length: 1, timestamp: 573
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:33.160
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, r) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 334, length: 1, timestamp: 574
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:34.168
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, re) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 334, length: 0, timestamp: 575
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:34.499
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(item)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 335, length: 0, timestamp: 576
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:37.146
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(ite)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 448, length: 1, timestamp: 577
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:37.302
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(it)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 447, length: 1, timestamp: 578
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:37.464
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(i)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 446, length: 1, timestamp: 579
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:37.630
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push()
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 445, length: 1, timestamp: 580
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:37.758
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(r)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 445, length: 0, timestamp: 581
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:38.020
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(re)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 446, length: 0, timestamp: 582
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:38.305
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 447, length: 0, timestamp: 583
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:45.944
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 457, length: 1, timestamp: 585
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:48.834
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(n)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 468, length: 0, timestamp: 590
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:49.064
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(nu)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 469, length: 0, timestamp: 591
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:49.283
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(nul)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 470, length: 0, timestamp: 592
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:36:49.428
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 471, length: 0, timestamp: 593
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:04.939
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 485, length: 1, timestamp: 595
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:08.504
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(e)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 487, length: 0, timestamp: 598
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:08.764
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(er)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 488, length: 0, timestamp: 599
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:08.944
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 489, length: 0, timestamp: 600
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:16.887
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if (e)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 504, length: 0, timestamp: 609
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:17.201
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if (er)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 505, length: 0, timestamp: 610
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:17.379
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if (err)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 506, length: 0, timestamp: 611
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:18.595
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if (er)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 506, length: 1, timestamp: 612
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:18.782
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if (e)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 505, length: 1, timestamp: 613
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:18.928
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if ()
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 504, length: 1, timestamp: 614
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:19.106
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if 
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 503, length: 2, timestamp: 615
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:24.794
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(e)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 523, length: 0, timestamp: 630
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:25.075
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(er)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 524, length: 0, timestamp: 631
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:25.240
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 525, length: 0, timestamp: 632
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:25.478
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err,)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 526, length: 0, timestamp: 633
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:25.782
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, )
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 527, length: 0, timestamp: 634
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:26.306
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, n)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 528, length: 0, timestamp: 635
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:26.556
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, nu)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 529, length: 0, timestamp: 636
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:26.797
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, nul)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 530, length: 0, timestamp: 637
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:26.911
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, null)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 531, length: 0, timestamp: 638
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:28.298
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, nul)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 531, length: 1, timestamp: 639
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:28.460
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, nu)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 530, length: 1, timestamp: 640
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:28.625
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, n)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 529, length: 1, timestamp: 641
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:28.754
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, )
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 528, length: 1, timestamp: 642
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:29.126
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 528, length: 0, timestamp: 643
text:>[]<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:29.214
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 529, length: 1, timestamp: 644
text:>]<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:33.337
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 550, length: 1, timestamp: 653
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:35.236
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				call
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 554, length: 1, timestamp: 659
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:36.917
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(n)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 559, length: 0, timestamp: 665
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:37.173
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(nu)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 560, length: 0, timestamp: 666
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:37.388
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(nul)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 561, length: 0, timestamp: 667
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:37.555
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 562, length: 0, timestamp: 668
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:38.169
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null,)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 563, length: 0, timestamp: 669
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:38.413
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, )
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 564, length: 0, timestamp: 670
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:40.635
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, a)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 565, length: 0, timestamp: 671
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:40.985
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, ar)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 566, length: 0, timestamp: 672
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:41.115
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arr)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 567, length: 0, timestamp: 673
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:41.510
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrF)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 568, length: 0, timestamp: 674
text:>F<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:41.739
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFi)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 569, length: 0, timestamp: 675
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:41.823
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFil)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 570, length: 0, timestamp: 676
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:42.138
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilt)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 571, length: 0, timestamp: 677
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:42.229
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilte)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 572, length: 0, timestamp: 678
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:42.471
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilter)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 573, length: 0, timestamp: 679
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:42.756
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFiltere)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 574, length: 0, timestamp: 680
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:43.013
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFiltered)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 575, length: 0, timestamp: 681
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:43.499
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredR)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 576, length: 0, timestamp: 682
text:>R<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:43.738
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRe)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 577, length: 0, timestamp: 683
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:44.013
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRec)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 578, length: 0, timestamp: 684
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:44.166
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredReco)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 579, length: 0, timestamp: 685
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:44.330
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecor)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 580, length: 0, timestamp: 686
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:44.659
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecord)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 581, length: 0, timestamp: 687
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:37:44.854
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) -><<<
Document event: offset: 582, length: 0, timestamp: 688
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:04.627
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(n)<<<
Document event: offset: 640, length: 0, timestamp: 699
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:04.865
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(nu)<<<
Document event: offset: 641, length: 0, timestamp: 700
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:05.071
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(nul)<<<
Document event: offset: 642, length: 0, timestamp: 701
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:05.246
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null)<<<
Document event: offset: 643, length: 0, timestamp: 702
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:05.481
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null,)<<<
Document event: offset: 644, length: 0, timestamp: 703
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:05.674
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, )<<<
Document event: offset: 645, length: 0, timestamp: 704
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:07.974
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, t)<<<
Document event: offset: 646, length: 0, timestamp: 705
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:08.116
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, tr)<<<
Document event: offset: 647, length: 0, timestamp: 706
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:08.246
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, tru)<<<
Document event: offset: 648, length: 0, timestamp: 707
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:08.394
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true)<<<
Document event: offset: 649, length: 0, timestamp: 708
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:08.805
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true,)<<<
Document event: offset: 650, length: 0, timestamp: 709
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:09.003
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, )<<<
Document event: offset: 651, length: 0, timestamp: 710
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:10.159
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, r)<<<
Document event: offset: 652, length: 0, timestamp: 711
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:10.398
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, re)<<<
Document event: offset: 653, length: 0, timestamp: 712
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:10.643
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, rec)<<<
Document event: offset: 654, length: 0, timestamp: 713
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:10.748
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, reco)<<<
Document event: offset: 655, length: 0, timestamp: 714
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:10.915
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, recor)<<<
Document event: offset: 656, length: 0, timestamp: 715
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:39:11.155
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)<<<
Document event: offset: 657, length: 0, timestamp: 716
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:40:10.065
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	<<<
Document event: offset: 662, length: 1, timestamp: 718
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:40:11.900
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	get<<<
Document event: offset: 665, length: 1, timestamp: 723
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 13:40:14.190
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: ()<<<
Document event: offset: 672, length: 1, timestamp: 731
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:40:21.789
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: ()<<<
Document event: offset: 696, length: 1, timestamp: 753
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-20 13:40:29.822
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		@user = user
		@roles = roles
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: ()<<<
Document event: offset: 721, length: 1, timestamp: 776
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:51.699
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (u)
	<<<
Document event: offset: 108, length: 0, timestamp: 109
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:52.170
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: ()
	<<<
Document event: offset: 108, length: 1, timestamp: 110
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:52.420
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (t)
	<<<
Document event: offset: 108, length: 0, timestamp: 111
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:52.572
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (to)
	<<<
Document event: offset: 109, length: 0, timestamp: 112
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:52.818
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (tok)
	<<<
Document event: offset: 110, length: 0, timestamp: 113
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:52.990
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (toke)
	<<<
Document event: offset: 111, length: 0, timestamp: 114
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:16:53.097
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token)
	<<<
Document event: offset: 112, length: 0, timestamp: 115
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:17:13.442
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token) ->
	
	<<<
Document event: offset: 120, length: 1, timestamp: 120
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:17:18.923
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token) ->
	resolveRoles: (t)
	<<<
Document event: offset: 135, length: 0, timestamp: 136
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:17:19.126
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token) ->
	resolveRoles: (to)
	<<<
Document event: offset: 136, length: 0, timestamp: 137
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:17:19.361
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token) ->
	resolveRoles: (tok)
	<<<
Document event: offset: 137, length: 0, timestamp: 138
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:17:19.565
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token) ->
	resolveRoles: (toke)
	<<<
Document event: offset: 138, length: 0, timestamp: 139
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:17:19.755
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('./RecordFilter')
class ResolvableRecordFilter extends RecordFilter
	constructor: (token) ->
	resolveRoles: (token)
	<<<
Document event: offset: 139, length: 0, timestamp: 140
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:15.961
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
		
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 126, length: 30, timestamp: 787
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:16.176
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->
	
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 125, length: 1, timestamp: 788
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:16.554
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token, user, roles) ->

		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 124, length: 1, timestamp: 789
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:21.764
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 105, length: 13, timestamp: 791
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:39.738
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: [
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 82, length: 1, timestamp: 792
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:39.900
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles: 
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 81, length: 1, timestamp: 793
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.057
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles:
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 80, length: 1, timestamp: 794
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.218
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	roles
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 79, length: 1, timestamp: 795
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.378
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	role
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 78, length: 1, timestamp: 796
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.533
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	rol
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 77, length: 1, timestamp: 797
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.673
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	ro
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 76, length: 1, timestamp: 798
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.868
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	r
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 75, length: 1, timestamp: 799
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:40.954
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null
	
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 74, length: 1, timestamp: 800
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:41.116
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: null
	token: null

	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 73, length: 1, timestamp: 801
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:42.334
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: nul
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 56, length: 1, timestamp: 803
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:42.507
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: nu
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 55, length: 1, timestamp: 804
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:42.664
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: n
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 54, length: 1, timestamp: 805
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:42.820
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user: 
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 53, length: 1, timestamp: 806
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:42.988
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user:
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 52, length: 1, timestamp: 807
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:43.131
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	user
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 51, length: 1, timestamp: 808
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:43.294
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	use
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 50, length: 1, timestamp: 809
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:43.461
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	us
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 49, length: 1, timestamp: 810
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:43.649
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	u
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 48, length: 1, timestamp: 811
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:43.822
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 47, length: 1, timestamp: 812
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:43.994
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter

	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @roles
	getToken: () -> @token<<<
Document event: offset: 46, length: 1, timestamp: 813
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:49.531
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @role
	getToken: () -> @token<<<
Document event: offset: 634, length: 1, timestamp: 815
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:49.975
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @rol
	getToken: () -> @token<<<
Document event: offset: 633, length: 1, timestamp: 816
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:49.999
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @ro
	getToken: () -> @token<<<
Document event: offset: 632, length: 1, timestamp: 817
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.025
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @r
	getToken: () -> @token<<<
Document event: offset: 631, length: 1, timestamp: 818
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.049
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> @
	getToken: () -> @token<<<
Document event: offset: 630, length: 1, timestamp: 819
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.073
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -> 
	getToken: () -> @token<<<
Document event: offset: 629, length: 1, timestamp: 820
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.097
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () ->
	getToken: () -> @token<<<
Document event: offset: 628, length: 1, timestamp: 821
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.121
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () -
	getToken: () -> @token<<<
Document event: offset: 627, length: 1, timestamp: 822
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.145
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: () 
	getToken: () -> @token<<<
Document event: offset: 626, length: 1, timestamp: 823
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.170
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: ()
	getToken: () -> @token<<<
Document event: offset: 625, length: 1, timestamp: 824
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.194
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: (
	getToken: () -> @token<<<
Document event: offset: 624, length: 1, timestamp: 825
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.218
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles: 
	getToken: () -> @token<<<
Document event: offset: 623, length: 1, timestamp: 826
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.243
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles:
	getToken: () -> @token<<<
Document event: offset: 622, length: 1, timestamp: 827
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.266
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRoles
	getToken: () -> @token<<<
Document event: offset: 621, length: 1, timestamp: 828
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.290
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRole
	getToken: () -> @token<<<
Document event: offset: 620, length: 1, timestamp: 829
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.315
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRol
	getToken: () -> @token<<<
Document event: offset: 619, length: 1, timestamp: 830
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.339
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getRo
	getToken: () -> @token<<<
Document event: offset: 618, length: 1, timestamp: 831
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.363
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	getR
	getToken: () -> @token<<<
Document event: offset: 617, length: 1, timestamp: 832
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.387
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	get
	getToken: () -> @token<<<
Document event: offset: 616, length: 1, timestamp: 833
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.411
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	ge
	getToken: () -> @token<<<
Document event: offset: 615, length: 1, timestamp: 834
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.435
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	g
	getToken: () -> @token<<<
Document event: offset: 614, length: 1, timestamp: 835
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.459
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user
	
	getToken: () -> @token<<<
Document event: offset: 613, length: 1, timestamp: 836
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:50.800
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @user

	getToken: () -> @token<<<
Document event: offset: 612, length: 1, timestamp: 837
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.006
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @use
	getToken: () -> @token<<<
Document event: offset: 609, length: 1, timestamp: 839
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.211
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @us
	getToken: () -> @token<<<
Document event: offset: 608, length: 1, timestamp: 840
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.655
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @u
	getToken: () -> @token<<<
Document event: offset: 607, length: 1, timestamp: 841
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.679
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> @
	getToken: () -> @token<<<
Document event: offset: 606, length: 1, timestamp: 842
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.703
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -> 
	getToken: () -> @token<<<
Document event: offset: 605, length: 1, timestamp: 843
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.728
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () ->
	getToken: () -> @token<<<
Document event: offset: 604, length: 1, timestamp: 844
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.752
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () -
	getToken: () -> @token<<<
Document event: offset: 603, length: 1, timestamp: 845
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.775
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: () 
	getToken: () -> @token<<<
Document event: offset: 602, length: 1, timestamp: 846
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.800
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: ()
	getToken: () -> @token<<<
Document event: offset: 601, length: 1, timestamp: 847
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.824
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: (
	getToken: () -> @token<<<
Document event: offset: 600, length: 1, timestamp: 848
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.848
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser: 
	getToken: () -> @token<<<
Document event: offset: 599, length: 1, timestamp: 849
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.872
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser:
	getToken: () -> @token<<<
Document event: offset: 598, length: 1, timestamp: 850
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.897
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUser
	getToken: () -> @token<<<
Document event: offset: 597, length: 1, timestamp: 851
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.921
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUse
	getToken: () -> @token<<<
Document event: offset: 596, length: 1, timestamp: 852
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:51.944
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getUs
	getToken: () -> @token<<<
Document event: offset: 595, length: 1, timestamp: 853
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:52.092
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getU
	getToken: () -> @token<<<
Document event: offset: 594, length: 1, timestamp: 854
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:52.271
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	get
	getToken: () -> @token<<<
Document event: offset: 593, length: 1, timestamp: 855
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:52.441
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	ge
	getToken: () -> @token<<<
Document event: offset: 592, length: 1, timestamp: 856
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:52.653
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	g
	getToken: () -> @token<<<
Document event: offset: 591, length: 1, timestamp: 857
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:52.758
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	
	getToken: () -> @token<<<
Document event: offset: 590, length: 1, timestamp: 858
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:18:52.942
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)

	getToken: () -> @token<<<
Document event: offset: 589, length: 1, timestamp: 859
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:19:44.359
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token<<<
Document event: offset: 82, length: 1, timestamp: 881
text:>]<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:16.890
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolveConten<<<
Document event: offset: 653, length: 1, timestamp: 897
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:17.034
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolveConte<<<
Document event: offset: 652, length: 1, timestamp: 898
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:19.538
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolveContext: ()<<<
Document event: offset: 657, length: 1, timestamp: 904
text:>)<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:28.204
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolveontext: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 909
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:28.337
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolventext: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 910
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:28.522
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolvetext: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 911
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:28.684
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolveext: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 912
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:28.846
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolvext: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 913
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:29.008
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolvet: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 914
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:29.172
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: () ->
		<<<
Document event: offset: 647, length: 1, timestamp: 915
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:33.650
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (c) ->
		<<<
Document event: offset: 650, length: 0, timestamp: 916
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:33.877
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (ca) ->
		<<<
Document event: offset: 651, length: 0, timestamp: 917
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:34.005
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (cal) ->
		<<<
Document event: offset: 652, length: 0, timestamp: 918
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:34.167
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (call) ->
		<<<
Document event: offset: 653, length: 0, timestamp: 919
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:34.394
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callb) ->
		<<<
Document event: offset: 654, length: 0, timestamp: 920
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:34.487
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callba) ->
		<<<
Document event: offset: 655, length: 0, timestamp: 921
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:34.764
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callbac) ->
		<<<
Document event: offset: 656, length: 0, timestamp: 922
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:20:34.888
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		<<<
Document event: offset: 657, length: 0, timestamp: 923
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:21:11.712
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) >
		<<<
Document event: offset: 660, length: 1, timestamp: 924
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:21:11.947
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) =>
		<<<
Document event: offset: 660, length: 0, timestamp: 925
text:>=<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:21:13.154
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) >
		<<<
Document event: offset: 660, length: 1, timestamp: 926
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:21:13.699
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		<<<
Document event: offset: 660, length: 0, timestamp: 927
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:23:35.323
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
Q
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		<<<
Document event: offset: 27, length: 1, timestamp: 931
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:23:35.472
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')

class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		<<<
Document event: offset: 26, length: 1, timestamp: 932
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:23:47.513
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()<<<
Document event: offset: 693, length: 1, timestamp: 961
text:>)<



!ENTRY org.eclipse.jface.text 4 0 2012-09-20 15:25:44.843
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.NullPointerException
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:669)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:674)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:387)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:443)
	at org.eclipse.wst.jsdt.internal.core.CompilationUnitProblemFinder.accept(CompilationUnitProblemFinder.java:174)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForBinding(LookupEnvironment.java:279)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:132)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:766)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:720)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.Scope.getJavaLangString(Scope.java:1745)
	at org.eclipse.wst.jsdt.core.dom.DefaultBindingResolver.resolveExpressionType(DefaultBindingResolver.java:604)
	at org.eclipse.wst.jsdt.core.dom.Expression.resolveTypeBinding(Expression.java:111)
	at org.eclipse.wst.jsdt.internal.corext.refactoring.nls.NLSHintHelper.getAccessorClassReference(NLSHintHelper.java:97)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo(NLSStringHover.java:96)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getHoverInfo2(AbstractJavaEditorTextHover.java:95)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:147)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:78)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.apache.log4j 4 0 2012-09-20 15:26:43.665
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')

QRefDatabase = require('../db/QRefDatabase')
###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 32, length: 30, timestamp: 4
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:26:46.364
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')

###
Database middleware class that handles connection setup and exposes available data models.
Creating multiple instances of this class will create a new connection for each instance; therefore, 
the application only spins up one copy of this class at startup and exposes a global variable named QRefDatabase 
which is reused through the application. The convience method {#instance} is used to grab a reference off of 
this global QRefDatabase variable. Only one connection to the MongoDB server is ever needed for the life of the 
application because all requests to mongo occur in an evented manner and a single connection object can handle 
multiple requests at a time. 

@example Getting a reference from QRefDatabase global variable
  db = QRefDatabase.instance()

@author Nathan Klick
@copyright QRef 2012
###
class QRefDatabase
	###
	@property [Mongoose.Connection] The underlying mongoose connection object.
	###
	connection: null
	###
	@property [String] The mongodb URL to use in establishing the mongoose connection object.
	###
	url: 'mongodb://qref:qref@localhost/qref'
	###
	@property [UserSchemaInternal] A reference to the User model.
	###
	User: null
	###
	@property [AuthTokenSchemaInternal] A reference to the AuthToken model.
	###
	AuthToken: null
	###
	@property [RoleSchemaInternal] A reference to the Role model.
	###
	Role: null
	###
	@property [RecoveryQuestionSchemaInternal] A reference to the RecoveryQuestion model.
	###
	RecoveryQuestion: null
	###
	@property [AircraftManufacturerSchemaInternal] A reference to the AircraftManufacturer model.
	###
	AircraftManufacturer: null
	###
	@property [AircraftModelSchemaInternal] A reference to the AircraftModel model.
	###
	AircraftModel: null
	###
	@property [AircraftChecklistSchemaInternal] A reference to the AircraftChecklist model.
	###
	AircraftChecklist: null
	###
	@property [ProductSchemaInternal] A reference to the Product model.
	###
	Product: null
	###
	@property [UserProductSchemaInternal] A reference to the UserProduct model.
	###
	UserProduct: null
	###
	@property [Mongoose.Schema] A convenience property for accessing the Mongoose.Schema object.
	###
	Schema: mongoose.Schema
	###
	Create a new instance of the QRefDatabase object, connects to mongodb, and calls the {#initialize} method.
	###
	constructor: () ->
		@connection = mongoose.createConnection(@url)
		@.initialize()
	###
	Attaches all the schemas to mongoose and sets up the model references.
	###
	initialize: () ->
		RoleSchema = require('../schema/RoleSchema')
		@Role = @connection.model('user.roles', RoleSchema)
		RecoveryQuestionSchema = require('../schema/RecoveryQuestionSchema')
		@RecoveryQuestion = @connection.model('user.recovery.questions', RecoveryQuestionSchema)
		UserSchema = require('../schema/UserSchema')
		@User = @connection.model('users', UserSchema)
		AuthTokenSchema = require('../schema/AuthTokenSchema')
		@AuthToken = @connection.model('user.tokens', AuthTokenSchema)
		AircraftManufacturerSchema = require('../schema/AircraftManufacturerSchema')
		@AircraftManufacturer = @connection.model('aircraft.manufacturers', AircraftManufacturerSchema)
		AircraftModelSchema = require('../schema/AircraftModelSchema')
		@AircraftModel = @connection.model('aircraft.models', AircraftModelSchema)
		AircraftChecklistSchema = require('../schema/AircraftChecklistSchema')
		@AircraftChecklist = @connection.model('aircraft.checklists', AircraftChecklistSchema)
		ProductSchema = require('../schema/ProductSchema')
		@Product = @connection.model('products', ProductSchema)
		UserProductSchema = require('../schema/UserProductSchema')
		@UserProduct = @connection.model('user.products', UserProductSchema)
	###
	Returns a reference to the underlying mongoose connection.
	@return [Mongoose.Connection] The underlying mongoose connection object.
	###
	getConnection: () -> @connection
	###
	Returns the URL used to establish the underlying mongodb connection.
	@return [String] The mongodb URL.
	###
	getUrl: () -> @url
	###
	Safety method for retrieving a reference to the current instance of this object.
	@return [QRefDatabase] A reference to the current instance of this object.
	###
	instance: () -> @
module.exports = new QRefDatabase()
		<<<
Document event: offset: 32, length: 76, timestamp: 2
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:09.484
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.findById
		<<<
Document event: offset: 802, length: 2, timestamp: 998
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:09.928
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.findByI
		<<<
Document event: offset: 801, length: 1, timestamp: 999
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:09.952
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.findBy
		<<<
Document event: offset: 800, length: 1, timestamp: 1000
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:09.976
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.findB
		<<<
Document event: offset: 799, length: 1, timestamp: 1001
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:10.000
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.find
		<<<
Document event: offset: 798, length: 1, timestamp: 1002
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:10.024
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.fin
		<<<
Document event: offset: 797, length: 1, timestamp: 1003
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:10.049
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.fi
		<<<
Document event: offset: 796, length: 1, timestamp: 1004
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:10.072
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.f
		<<<
Document event: offset: 795, length: 1, timestamp: 1005
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:10.270
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.
		<<<
Document event: offset: 794, length: 1, timestamp: 1006
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:13.163
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('')
		<<<
Document event: offset: 800, length: 0, timestamp: 1013
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:17.337
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				
		<<<
Document event: offset: 814, length: 1, timestamp: 1023
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:21.090
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@)
		<<<
Document event: offset: 822, length: 0, timestamp: 1032
text:>@<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:21.702
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@o)
		<<<
Document event: offset: 823, length: 0, timestamp: 1033
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:21.861
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@ot)
		<<<
Document event: offset: 824, length: 0, timestamp: 1034
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:22.034
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@o)
		<<<
Document event: offset: 824, length: 1, timestamp: 1035
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:22.212
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@)
		<<<
Document event: offset: 823, length: 1, timestamp: 1036
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:22.340
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@t)
		<<<
Document event: offset: 823, length: 0, timestamp: 1037
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:22.636
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@to)
		<<<
Document event: offset: 824, length: 0, timestamp: 1038
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:22.926
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@toe)
		<<<
Document event: offset: 825, length: 0, timestamp: 1039
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:23.138
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@toek)
		<<<
Document event: offset: 826, length: 0, timestamp: 1040
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:23.597
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@toe)
		<<<
Document event: offset: 826, length: 1, timestamp: 1041
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:23.745
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@to)
		<<<
Document event: offset: 825, length: 1, timestamp: 1042
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:24.031
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@tok)
		<<<
Document event: offset: 825, length: 0, timestamp: 1043
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:24.141
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@toke)
		<<<
Document event: offset: 826, length: 0, timestamp: 1044
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:24.293
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
		<<<
Document event: offset: 827, length: 0, timestamp: 1045
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:40.079
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne(e)
		<<<
Document event: offset: 844, length: 0, timestamp: 1056
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:40.411
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne()
		<<<
Document event: offset: 844, length: 1, timestamp: 1057
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:41.065
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne(())
		<<<
Document event: offset: 844, length: 0, timestamp: 1058
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:42.041
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((e))
		<<<
Document event: offset: 845, length: 0, timestamp: 1059
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:42.269
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((er))
		<<<
Document event: offset: 846, length: 0, timestamp: 1060
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:42.438
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err))
		<<<
Document event: offset: 847, length: 0, timestamp: 1061
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:43.138
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err,))
		<<<
Document event: offset: 848, length: 0, timestamp: 1062
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:43.257
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, ))
		<<<
Document event: offset: 849, length: 0, timestamp: 1063
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:43.575
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, t))
		<<<
Document event: offset: 850, length: 0, timestamp: 1064
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:43.733
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk))
		<<<
Document event: offset: 851, length: 0, timestamp: 1065
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:44.693
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) )
		<<<
Document event: offset: 853, length: 0, timestamp: 1066
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:44.925
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) -)
		<<<
Document event: offset: 854, length: 0, timestamp: 1067
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:45.288
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->)
		<<<
Document event: offset: 855, length: 0, timestamp: 1068
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:45.635
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					
				)
		<<<
Document event: offset: 856, length: 0, timestamp: 1069
text:>
					
				<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:52.021
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (e)
				)
		<<<
Document event: offset: 867, length: 0, timestamp: 1074
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:52.286
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (er)
				)
		<<<
Document event: offset: 868, length: 0, timestamp: 1075
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:52.467
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (err)
				)
		<<<
Document event: offset: 869, length: 0, timestamp: 1076
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:53.025
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (err?)
				)
		<<<
Document event: offset: 870, length: 0, timestamp: 1077
text:>?<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:53.729
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (err)
				)
		<<<
Document event: offset: 870, length: 1, timestamp: 1078
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:53.880
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (er)
				)
		<<<
Document event: offset: 869, length: 1, timestamp: 1079
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:54.050
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if (e)
				)
		<<<
Document event: offset: 868, length: 1, timestamp: 1080
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:54.210
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if ()
				)
		<<<
Document event: offset: 867, length: 1, timestamp: 1081
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:54.391
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if 
				)
		<<<
Document event: offset: 866, length: 2, timestamp: 1082
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:58.805
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if err?
						callback(e)
				)
		<<<
Document event: offset: 887, length: 0, timestamp: 1097
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:59.056
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if err?
						callback(er)
				)
		<<<
Document event: offset: 888, length: 0, timestamp: 1098
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 15:32:59.236
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: []
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.filterRecord(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	filterRecord: (record, callback) ->
		callback(null, true, record)
	getToken: () -> @token
	resolve: (callback) ->
		db = QRefDatabase.instance()
		
		db.AuthTokens.where('token')
				.equals(@token)
				.findOne((err, tk) ->
					if err?
						callback(err)
				)
		<<<
Document event: offset: 889, length: 0, timestamp: 1099
text:>r<


