!SESSION 2012-09-19 12:15:53.765 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -data C:\SourceControl\QRef\trunk\Workspace -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_6.log
Created Time: 2012-09-20 16:57:34.998

!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:34.999
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query,)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 885, length: 0, timestamp: 2027
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:35.136
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, )
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 886, length: 0, timestamp: 2028
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:40.551
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, c)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 887, length: 0, timestamp: 2029
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:40.856
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, ca)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 888, length: 0, timestamp: 2030
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:40.996
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, cal)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 889, length: 0, timestamp: 2031
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:41.140
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, call)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 890, length: 0, timestamp: 2032
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:41.394
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callb)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 891, length: 0, timestamp: 2033
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:41.488
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callba)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 892, length: 0, timestamp: 2034
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:41.775
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callbac)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 893, length: 0, timestamp: 2035
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:41.881
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 894, length: 0, timestamp: 2036
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:48.186
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		call
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 907, length: 1, timestamp: 2046
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:51.225
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(n)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 912, length: 0, timestamp: 2052
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:51.567
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(nu)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 913, length: 0, timestamp: 2053
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:51.816
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(nul)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 914, length: 0, timestamp: 2054
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:51.980
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 915, length: 0, timestamp: 2055
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:52.225
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null,)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 916, length: 0, timestamp: 2056
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:52.415
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null, )
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 917, length: 0, timestamp: 2057
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:56.129
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null, q)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 918, length: 0, timestamp: 2058
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:56.360
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null, qu)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 919, length: 0, timestamp: 2059
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:56.567
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null, que)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 920, length: 0, timestamp: 2060
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:56.797
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null, quer)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 921, length: 0, timestamp: 2061
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:57:56.894
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
async = require('async')
class RecordFilter
	token: null
	user: null
	roles: null
	constructor: (token) ->
		@token = token
	filter: (arrRecords, callback) ->
		arrFilteredRecords = []
		async.forEach(arrRecords,
			(item, cb) =>
				@.retrieve(item, 
					(err, include, rec) ->
						if err?
							cb(err)
							return
						
						if include
							arrFilteredRecords.push(rec)
						
						cb(null)
				)
			,(err) ->
				if err?
					callback(err, [])
					return
				callback(null, arrFilteredRecords)
		)
	retrieve: (record, callback) ->
		callback(null, true, record)
	create: (callback) ->
		callback(null, true)
	update: (record, callback) ->
		callback(null, true, record)
	delete: (record, callback) ->
		callback(null, true, record)
	constrainQuery: (query, callback) ->
		callback(null, query)
	getToken: () -> @token
	getRoles: () -> @roles
	getUser: () -> @user
	isInRole: (roleName) ->
		if not @roles
			return false
			
		return true for r in @roles when r is roleName
		return false
	resolve: (callback) ->
		db = QRefDatabase.instance()
		@roles = []		
		db.AuthToken.where('token')
				.equals(@token)
				.populate('user')
				.findOne((err, tk) =>
					if err?
						callback(err)
						return
					
					if not tk?
						callback(new Error('Token not found'))
						return
					
					@user = tk.user
					
					async.forEach(tk.user.roles, 
						(item, cb) ->
							db.Role.findById(item, 
								(err, role) ->
									if err?
										cb(err)
										return
									
									if not role?
										cb(new Error('Role not found'))
										return
										
									@roles.push(role.roleName)
									cb(null)
							)
						,(err) ->
							if err?
								callback(err)
								return
								
							callback(null)
					)						
					
				)
module.exports = RecordFilter<<<
Document event: offset: 922, length: 0, timestamp: 2062
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:26.201
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1975, length: 1, timestamp: 784
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:32.045
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (q)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1993, length: 0, timestamp: 803
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:32.245
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (qu)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1994, length: 0, timestamp: 804
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:32.392
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (que)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1995, length: 0, timestamp: 805
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:32.568
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (quer)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1996, length: 0, timestamp: 806
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:32.651
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1997, length: 0, timestamp: 807
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:33.002
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query,)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1998, length: 0, timestamp: 808
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:33.118
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, )
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1999, length: 0, timestamp: 809
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:33.398
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, c)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2000, length: 0, timestamp: 810
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:33.684
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, ca)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2001, length: 0, timestamp: 811
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:33.767
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, cal)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2002, length: 0, timestamp: 812
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:33.933
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, call)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2003, length: 0, timestamp: 813
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:34.160
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callb)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2004, length: 0, timestamp: 814
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:34.301
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callba)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2005, length: 0, timestamp: 815
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:34.532
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callbac)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2006, length: 0, timestamp: 816
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:58:34.694
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2007, length: 0, timestamp: 817
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:01.988
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						q
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2191, length: 16, timestamp: 823
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:09.009
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['']
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2197, length: 0, timestamp: 829
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:23.696
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query[]
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2240, length: 16, timestamp: 851
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:26.518
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query[
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2197, length: 1, timestamp: 852
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:26.664
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2196, length: 1, timestamp: 853
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:35.400
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['']
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2197, length: 0, timestamp: 855
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:46.005
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						query['']
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2225, length: 0, timestamp: 874
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:50.440
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						query
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2224, length: 2, timestamp: 880
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:50.576
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						quer
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2223, length: 1, timestamp: 881
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:50.682
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						que
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2222, length: 1, timestamp: 882
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:50.867
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						qu
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2221, length: 1, timestamp: 883
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:51.025
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						q
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2220, length: 1, timestamp: 884
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:51.163
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
						
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2219, length: 1, timestamp: 885
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:51.345
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2218, length: 1, timestamp: 886
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:51.517
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
				
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2217, length: 1, timestamp: 887
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:51.698
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
			
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2216, length: 1, timestamp: 888
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:51.930
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
		
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2215, length: 1, timestamp: 889
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:52.273
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
	
					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2214, length: 1, timestamp: 890
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:52.693
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null

					else if @.isInRole('Users')
						
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2213, length: 1, timestamp: 891
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 16:59:59.920
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['']
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2259, length: 0, timestamp: 899
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:12.228
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['']
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2292, length: 0, timestamp: 923
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:18.656
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete = fals
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2348, length: 1, timestamp: 941
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.100
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete = fal
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2347, length: 1, timestamp: 942
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.124
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete = fa
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2346, length: 1, timestamp: 943
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.148
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete = f
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2345, length: 1, timestamp: 944
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.172
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete = 
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2344, length: 1, timestamp: 945
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.197
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete =
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2343, length: 1, timestamp: 946
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.221
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete 
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2342, length: 1, timestamp: 947
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.245
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelete
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2341, length: 1, timestamp: 948
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.269
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDelet
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2340, length: 1, timestamp: 949
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.293
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDele
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2339, length: 1, timestamp: 950
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.317
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDel
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2338, length: 1, timestamp: 951
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.342
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canDe
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2337, length: 1, timestamp: 952
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.365
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						canD
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2336, length: 1, timestamp: 953
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.527
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						can
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2335, length: 1, timestamp: 954
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.696
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						ca
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2334, length: 1, timestamp: 955
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:19.883
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						c
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2333, length: 1, timestamp: 956
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:20.087
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
						
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2332, length: 1, timestamp: 957
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:22.987
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
					
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2331, length: 1, timestamp: 958
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:23.158
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
				
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2330, length: 1, timestamp: 959
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:23.325
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
			
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2329, length: 1, timestamp: 960
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:23.501
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
		
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2328, length: 1, timestamp: 961
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:23.663
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 
	
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2327, length: 1, timestamp: 962
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:23.814
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else 

				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2326, length: 1, timestamp: 963
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:24.167
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					else
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2323, length: 1, timestamp: 965
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:24.327
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					els
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2322, length: 1, timestamp: 966
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:24.494
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					el
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2321, length: 1, timestamp: 967
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:24.689
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					e
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2320, length: 1, timestamp: 968
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:24.806
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
					
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2319, length: 1, timestamp: 969
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:24.965
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2318, length: 1, timestamp: 970
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:25.123
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
			
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2317, length: 1, timestamp: 971
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:25.272
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
		
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2316, length: 1, timestamp: 972
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:25.436
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
	
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2315, length: 1, timestamp: 973
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:25.621
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false

				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2314, length: 1, timestamp: 974
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:39.803
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2016, length: 16, timestamp: 993
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:40.027
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
	
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2015, length: 1, timestamp: 994
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:40.260
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->

		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2014, length: 1, timestamp: 995
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:46.808
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, c)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2374, length: 16, timestamp: 997
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:46.970
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, )
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2373, length: 1, timestamp: 998
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:48.062
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, q)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2373, length: 0, timestamp: 999
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:48.249
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, qu)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2374, length: 0, timestamp: 1000
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:48.395
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, que)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2375, length: 0, timestamp: 1001
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:48.583
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, quer)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2376, length: 0, timestamp: 1002
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:00:48.670
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constraintQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 2377, length: 0, timestamp: 1003
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:27.287
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			f.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1635, length: 8, timestamp: 51
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:27.517
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			fi.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1636, length: 0, timestamp: 52
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:27.630
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			fil.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1637, length: 0, timestamp: 53
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:27.901
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filt.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1638, length: 0, timestamp: 54
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:28.417
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filte.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1639, length: 0, timestamp: 55
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:28.668
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1640, length: 0, timestamp: 56
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:30.883
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.c(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1642, length: 13, timestamp: 57
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:31.061
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.co(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1643, length: 0, timestamp: 58
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:31.267
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.con(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1644, length: 0, timestamp: 59
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:31.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.cons(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1645, length: 0, timestamp: 60
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:31.839
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.const(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1646, length: 0, timestamp: 61
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:31.964
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constr(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1647, length: 0, timestamp: 62
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:32.091
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constra(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1648, length: 0, timestamp: 63
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:32.308
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrai(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1649, length: 0, timestamp: 64
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:32.520
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrain(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1650, length: 0, timestamp: 65
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:32.730
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constraint(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1651, length: 0, timestamp: 66
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:33.142
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrain(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1651, length: 1, timestamp: 67
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:33.660
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQ(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1651, length: 0, timestamp: 68
text:>Q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:33.916
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQu(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1652, length: 0, timestamp: 69
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:34.100
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQue(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1653, length: 0, timestamp: 70
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:34.350
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuer(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1654, length: 0, timestamp: 71
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:34.445
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1655, length: 0, timestamp: 72
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:37.021
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, q) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1670, length: 4, timestamp: 73
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:37.346
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, qu) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1671, length: 0, timestamp: 74
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:37.639
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, que) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1672, length: 0, timestamp: 75
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:37.815
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, quer) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1673, length: 0, timestamp: 76
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:37.970
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, query) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1674, length: 0, timestamp: 77
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:38.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, quer) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1674, length: 1, timestamp: 78
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:38.856
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, que) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1673, length: 1, timestamp: 79
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:39.014
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, qu) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1672, length: 1, timestamp: 80
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:39.166
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, q) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1671, length: 1, timestamp: 81
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:39.332
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, ) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1670, length: 1, timestamp: 82
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:40.395
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, o) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1670, length: 0, timestamp: 83
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:41.865
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, ob) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1671, length: 0, timestamp: 84
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:42.008
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, obj) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1672, length: 0, timestamp: 85
text:>j<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:43.004
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQ) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1673, length: 0, timestamp: 86
text:>Q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:43.321
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQu) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1674, length: 0, timestamp: 87
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:43.500
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQue) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1675, length: 0, timestamp: 88
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:43.709
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuer) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1676, length: 0, timestamp: 89
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:43.784
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', user._id)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1677, length: 0, timestamp: 90
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:50.518
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
				
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1998, length: 66, timestamp: 91
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:50.823
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
			
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1997, length: 1, timestamp: 92
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:51.121
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
		
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1996, length: 1, timestamp: 93
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:51.440
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
	
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1995, length: 1, timestamp: 94
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:51.728
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery(token, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()

			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1994, length: 1, timestamp: 95
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:01:58.850
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find()
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1657, length: 5, timestamp: 97
text:>{}<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:08.376
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find({})
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1988, length: 0, timestamp: 99
text:>{}<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:10.600
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(o)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1988, length: 0, timestamp: 103
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:10.850
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(ob)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1989, length: 0, timestamp: 104
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:10.960
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(obj)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1990, length: 0, timestamp: 105
text:>j<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:11.460
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQ)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1991, length: 0, timestamp: 106
text:>Q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:11.744
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQu)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1992, length: 0, timestamp: 107
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:11.928
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQue)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1993, length: 0, timestamp: 108
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:12.118
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuer)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1994, length: 0, timestamp: 109
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:12.236
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not user?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1995, length: 0, timestamp: 110
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:18.155
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not q?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1824, length: 4, timestamp: 111
text:>q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:18.393
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not qu?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1825, length: 0, timestamp: 112
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:18.582
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not que?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1826, length: 0, timestamp: 113
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:18.798
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not quer?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1827, length: 0, timestamp: 114
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:18.905
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not query?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1828, length: 0, timestamp: 115
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:19.912
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not quer?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1828, length: 1, timestamp: 116
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:20.065
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not que?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1827, length: 1, timestamp: 117
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:20.237
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not qu?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1826, length: 1, timestamp: 118
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:20.396
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not q?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1825, length: 1, timestamp: 119
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:20.550
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not ?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1824, length: 1, timestamp: 120
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:20.967
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not o?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1824, length: 0, timestamp: 121
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:21.227
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not ob?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1825, length: 0, timestamp: 122
text:>b<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:21.343
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not obj?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1826, length: 0, timestamp: 123
text:>j<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:21.782
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQ?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1827, length: 0, timestamp: 124
text:>Q<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:22.181
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQu?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1828, length: 0, timestamp: 125
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:22.357
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQue?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1829, length: 0, timestamp: 126
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:22.566
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuer?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1830, length: 0, timestamp: 127
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:22.669
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1831, length: 0, timestamp: 128
text:>y<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:26.439
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					o
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1840, length: 106, timestamp: 129
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:02:32.334
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					objQuery = {}
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1849, length: 1, timestamp: 143
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:03:14.722
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RecordFilter = require('../RecordFilter')
async = require('async')
class AircraftChecklistFilter extends RecordFilter
	constructor: (token) ->
		super token
	retrieve: (record, callback) ->
		canRetrieve = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators') and not record.user?
						canRetrieve = true
					else if @.isInRole('Users') and record.user == @.getUser()._id and record.isDeleted == false
						canRetrieve = true
					else 
						canRetrieve = false
						
					cb(null)
				
			],
			(err) ->
				callback(err, canRetrieve, record)
		)
	create: (callback) ->
		canCreate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canCreate = true
					else 
						canCreate = false
						
					cb(null)
			],
			(err) ->
				callback(err, canCreate)
		)
	update: (record, callback) ->
		canUpdate = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canUpdate = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canUpdate = true
					else 
						canUpdate = false
				
					cb(null)
			],
			(err) ->
				callback(err, canUpdate, record)
		)
	delete: (record, callback) ->
		canDelete = false
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						canDelete = true
					else if @.isInRole('Users') and record.user == @.getUser()._id
						canDelete = true
					else 
						canDelete = false
				
					cb(null)
			],
			(err) ->
				callback(err, canDelete, record)
		)
	constrainQuery: (query, callback) ->
		async.series(
			[
				(cb) =>
					if not @user? or not @roles?
						@.resolve(cb)
					else
						cb(null)
				,(cb) =>
					if @.isInRole('Administrators')
						query['user'] = null
					else if @.isInRole('Users')
						query['user'] = @user._id
						query['isDeleted'] = false
				
					cb(null)
			],
			(err) ->
				callback(err, query)
		)
module.exports = AircraftChecklistFilter<<<
Document event: offset: 1984, length: 1, timestamp: 1004
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:03:59.409
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1840, length: 13, timestamp: 144
text:>resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:21.447
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3700, length: 1, timestamp: 146
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:30.059
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftCH
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3507, length: 1, timestamp: 172
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:30.209
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftC
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3506, length: 1, timestamp: 173
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:32.058
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecl
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3510, length: 1, timestamp: 179
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:32.211
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChec
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3509, length: 1, timestamp: 180
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:35.186
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(t)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3521, length: 0, timestamp: 193
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:35.307
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(to)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3522, length: 0, timestamp: 194
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:35.563
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(tok)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3523, length: 0, timestamp: 195
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:35.761
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(toke)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3524, length: 0, timestamp: 196
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:35.873
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3525, length: 0, timestamp: 197
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:40.317
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filer
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3757, length: 1, timestamp: 205
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:40.492
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			file
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3756, length: 1, timestamp: 206
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:04:40.643
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			fil
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3755, length: 1, timestamp: 207
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:02.219
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create(())
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3766, length: 0, timestamp: 219
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:03.685
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((e))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3767, length: 0, timestamp: 220
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:03.897
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((er))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3768, length: 0, timestamp: 221
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:04.058
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3769, length: 0, timestamp: 222
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:04.215
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err,))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3770, length: 0, timestamp: 223
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:04.439
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, ))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3771, length: 0, timestamp: 224
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:04.799
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, i))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3772, length: 0, timestamp: 225
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:04.929
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, is))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3773, length: 0, timestamp: 226
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:05.424
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isA))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3774, length: 0, timestamp: 227
text:>A<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:05.577
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAl))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3775, length: 0, timestamp: 228
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:05.756
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAll))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3776, length: 0, timestamp: 229
text:>l<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:05.968
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllo))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3777, length: 0, timestamp: 230
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:06.537
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllow))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3778, length: 0, timestamp: 231
text:>w<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:06.831
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowe))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3779, length: 0, timestamp: 232
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:07.037
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed))
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3780, length: 0, timestamp: 233
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:07.771
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed) )
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3782, length: 0, timestamp: 234
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:08.099
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed) -)
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3783, length: 0, timestamp: 235
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:08.500
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed) ->)
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3784, length: 0, timestamp: 236
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:08.825
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed) ->
				
			)
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3785, length: 0, timestamp: 237
text:>
				
			<



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:14.886
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed) ->
				
			)
			# Validate Permissions Here
			
			
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3839, length: 1061, timestamp: 238
text:><



!ENTRY org.apache.log4j 4 0 2012-09-20 17:05:28.650
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
AircraftChecklistFilter = require('../../../../security/filters/AircraftChecklistFilter')
###
Service route that allows the retrieval of all checklists and the creation of new checklists.
@example Service Methods (see {CreateAircraftChecklistAjaxRequest})
  Request Format: application/json
  Response Format: application/json
  
  GET /services/ajax/aircraft/checklists?token=:token
    :token - (Required) A valid authentication token.
    
  Retrieves all checklists.
  
  POST /services/ajax/aircraft/checklists
  	@BODY - (Required) CreateAircraftChecklistAjaxRequest
  	
  Creates a new checklist.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			filter.constrainQuery({}, (err, objQuery) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				if not objQuery?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				query = db.AircraftChecklist.find(objQuery)
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		filter = new AircraftChecklistFilter(token)
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			
			filter.create((err, isAllowed) ->
				
				newObj = new db.AircraftChecklist()
	
				newObj.manufacturer = req.body.manufacturer
				newObj.model = req.body.model
				newObj.preflight = req.body.preflight
				newObj.takeoff = req.body.takeoff
				newObj.landing = req.body.landing
				newObj.emergencies = req.body.emergenices
				#newObj.modelYear = req.body.modelYear
				
				if req.body?.tailNumber?
					newObj.tailNumber = req.body.tailNumber
					
				if req.body?.index?
					newObj.index = req.body.index
					
				if req.body?.user?
					newObj.user = req.body.user
				
				if req.body?.version?
					newObj.version = req.body.version
				else 
					newObj.version = 1
				
				if req.body?.productIcon?
					newObj.productIcon = req.body.productIcon
				
				#if req.body?.coverImage?
				#	newObj.coverImage = req.body.coverImage
				
				newObj.save((err) ->
					if err?
						resp = new AjaxResponse()
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new AjaxResponse()
					resp.setTotal(1)
					resp.addRecord(newObj)
					res.json(resp, 200)
				)
			)
			# Validate Permissions Here
			
			
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 3791, length: 1, timestamp: 281
text:><



!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:29.269
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getStyledText(NavigatorContentServiceLabelProvider.java:145)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getStyledText(NavigatorDecoratingLabelProvider.java:68)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getStyledText(DelegatingStyledCellLabelProvider.java:195)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getStyledText(DecoratingStyledCellLabelProvider.java:192)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:103)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:485)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2167)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:833)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:808)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:782)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:753)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1485)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:952)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1496)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7538)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5534)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1896)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5086)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4584)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2425)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1533)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6411)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4564)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5937)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:29.333
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:29.363
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:102)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getImage(NavigatorDecoratingLabelProvider.java:60)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getImage(DelegatingStyledCellLabelProvider.java:184)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getImage(DecoratingStyledCellLabelProvider.java:167)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:118)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:485)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2167)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:833)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:808)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:782)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:753)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1485)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:952)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1496)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7538)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5534)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1896)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5086)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4584)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2425)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1533)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6411)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4564)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5937)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:29.364
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:29.366
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getFont(NavigatorContentServiceLabelProvider.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getFont(NavigatorDecoratingLabelProvider.java:129)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getFont(DelegatingStyledCellLabelProvider.java:168)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getFont(DecoratingStyledCellLabelProvider.java:163)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:119)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:485)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2167)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:833)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:808)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:782)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:753)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1485)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:952)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1496)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7538)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5534)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1896)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5086)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4584)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2425)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1533)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6411)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4564)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5937)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:29.366
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:29.368
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getForeground(NavigatorContentServiceLabelProvider.java:224)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getForeground(NavigatorDecoratingLabelProvider.java:119)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getForeground(DelegatingStyledCellLabelProvider.java:137)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getForeground(DecoratingStyledCellLabelProvider.java:144)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:120)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:485)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2167)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:833)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:808)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:782)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:753)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1485)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:952)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1496)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7538)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5534)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1896)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5086)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4584)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2425)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1533)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6411)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4564)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5937)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:29.369
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:29.371
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getBackground(NavigatorContentServiceLabelProvider.java:242)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getBackground(NavigatorDecoratingLabelProvider.java:109)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getBackground(DelegatingStyledCellLabelProvider.java:153)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getBackground(DecoratingStyledCellLabelProvider.java:154)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:121)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:485)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2167)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:833)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:808)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:782)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:753)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1485)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:952)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1496)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7538)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5534)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1896)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5086)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4584)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2425)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1533)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6411)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4564)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5937)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:29.372
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:29.373
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isTriggerPoint(NavigatorContentDescriptor.java:426)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForTriggerPoint(NavigatorContentDescriptorManager.java:187)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsByTriggerPoint(NavigatorContentService.java:805)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findContentExtensionsByTriggerPoint(NavigatorContentService.java:654)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findContentExtensionsByTriggerPoint(NavigatorContentService.java:635)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.hasChildren(NavigatorContentServiceContentProvider.java:377)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.hasChildren(NavigatorContentServiceContentProvider.java:422)
	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2123)
	at org.eclipse.jface.viewers.TreeViewer.isExpandable(TreeViewer.java:588)
	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2153)
	at org.eclipse.jface.viewers.AbstractTreeViewer.updatePlus(AbstractTreeViewer.java:2835)
	at org.eclipse.jface.viewers.TreeViewer.updatePlus(TreeViewer.java:852)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:834)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:808)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:782)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:753)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1485)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:952)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1496)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7538)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5534)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1896)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5086)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4584)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2425)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1533)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6411)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4564)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5937)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4972)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:29.374
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.124
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.actions.CommonActionProviderDescriptor.isEnabledFor(CommonActionProviderDescriptor.java:235)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:258)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:263)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.findRelevantActionDescriptors(CommonActionDescriptorManager.java:235)
	at org.eclipse.ui.navigator.NavigatorActionService.fillActionBars(NavigatorActionService.java:248)
	at org.eclipse.ui.navigator.CommonNavigatorManager.selectionChanged(CommonNavigatorManager.java:222)
	at org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:164)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:162)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2188)
	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1211)
	at org.eclipse.ui.navigator.CommonViewer.handleSelect(CommonViewer.java:478)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1241)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:239)
	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:233)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:403)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.124
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.126
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.actions.CommonActionProviderDescriptor.isEnabledFor(CommonActionProviderDescriptor.java:235)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:258)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.findRelevantActionDescriptors(CommonActionDescriptorManager.java:235)
	at org.eclipse.ui.navigator.NavigatorActionService.fillActionBars(NavigatorActionService.java:248)
	at org.eclipse.ui.navigator.CommonNavigatorManager.selectionChanged(CommonNavigatorManager.java:222)
	at org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:164)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:162)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2188)
	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1211)
	at org.eclipse.ui.navigator.CommonViewer.handleSelect(CommonViewer.java:478)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1241)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:239)
	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:233)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:403)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.127
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.128
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.actions.CommonActionProviderDescriptor.isEnabledFor(CommonActionProviderDescriptor.java:235)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:258)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.findRelevantActionDescriptors(CommonActionDescriptorManager.java:235)
	at org.eclipse.ui.navigator.NavigatorActionService.fillActionBars(NavigatorActionService.java:248)
	at org.eclipse.ui.navigator.CommonNavigatorManager.selectionChanged(CommonNavigatorManager.java:222)
	at org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:164)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:162)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2188)
	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1211)
	at org.eclipse.ui.navigator.CommonViewer.handleSelect(CommonViewer.java:478)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1241)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:239)
	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:233)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:403)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.129
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.140
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:102)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getImage(NavigatorDecoratingLabelProvider.java:60)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getImage(DelegatingStyledCellLabelProvider.java:184)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getImage(DecoratingStyledCellLabelProvider.java:167)
	at org.eclipse.ui.navigator.CommonNavigatorManager.updateStatusBar(CommonNavigatorManager.java:308)
	at org.eclipse.ui.navigator.CommonNavigatorManager$1.selectionChanged(CommonNavigatorManager.java:74)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:888)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:886)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1226)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1251)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:262)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:256)
	at org.eclipse.jface.util.OpenStrategy$3.run(OpenStrategy.java:433)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.141
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.143
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceDescriptionProvider.getDescription(NavigatorContentServiceDescriptionProvider.java:58)
	at org.eclipse.ui.navigator.CommonNavigatorManager.updateStatusBar(CommonNavigatorManager.java:313)
	at org.eclipse.ui.navigator.CommonNavigatorManager$1.selectionChanged(CommonNavigatorManager.java:74)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:888)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:886)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1226)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1251)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:262)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:256)
	at org.eclipse.jface.util.OpenStrategy$3.run(OpenStrategy.java:433)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.144
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.226
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.actions.CommonActionProviderDescriptor.isEnabledFor(CommonActionProviderDescriptor.java:235)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:258)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:263)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.findRelevantActionDescriptors(CommonActionDescriptorManager.java:235)
	at org.eclipse.ui.navigator.NavigatorActionService.fillActionBars(NavigatorActionService.java:248)
	at org.eclipse.ui.navigator.CommonNavigatorManager$3.open(CommonNavigatorManager.java:184)
	at org.eclipse.ui.OpenAndLinkWithEditorHelper$InternalListener.open(OpenAndLinkWithEditorHelper.java:48)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:866)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:864)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1152)
	at org.eclipse.ui.navigator.CommonViewer.handleOpen(CommonViewer.java:462)
	at org.eclipse.jface.viewers.StructuredViewer$6.handleOpen(StructuredViewer.java:1256)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:275)
	at org.eclipse.jface.util.OpenStrategy.access$2(OpenStrategy.java:269)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:309)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.226
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.228
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.actions.CommonActionProviderDescriptor.isEnabledFor(CommonActionProviderDescriptor.java:235)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:258)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.findRelevantActionDescriptors(CommonActionDescriptorManager.java:235)
	at org.eclipse.ui.navigator.NavigatorActionService.fillActionBars(NavigatorActionService.java:248)
	at org.eclipse.ui.navigator.CommonNavigatorManager$3.open(CommonNavigatorManager.java:184)
	at org.eclipse.ui.OpenAndLinkWithEditorHelper$InternalListener.open(OpenAndLinkWithEditorHelper.java:48)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:866)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:864)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1152)
	at org.eclipse.ui.navigator.CommonViewer.handleOpen(CommonViewer.java:462)
	at org.eclipse.jface.viewers.StructuredViewer$6.handleOpen(StructuredViewer.java:1256)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:275)
	at org.eclipse.jface.util.OpenStrategy.access$2(OpenStrategy.java:269)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:309)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.229
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-21 10:46:30.230
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.actions.CommonActionProviderDescriptor.isEnabledFor(CommonActionProviderDescriptor.java:235)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.addProviderIfRelevant(CommonActionDescriptorManager.java:258)
	at org.eclipse.ui.internal.navigator.actions.CommonActionDescriptorManager.findRelevantActionDescriptors(CommonActionDescriptorManager.java:235)
	at org.eclipse.ui.navigator.NavigatorActionService.fillActionBars(NavigatorActionService.java:248)
	at org.eclipse.ui.navigator.CommonNavigatorManager$3.open(CommonNavigatorManager.java:184)
	at org.eclipse.ui.OpenAndLinkWithEditorHelper$InternalListener.open(OpenAndLinkWithEditorHelper.java:48)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:866)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:864)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1152)
	at org.eclipse.ui.navigator.CommonViewer.handleOpen(CommonViewer.java:462)
	at org.eclipse.jface.viewers.StructuredViewer$6.handleOpen(StructuredViewer.java:1256)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:275)
	at org.eclipse.jface.util.OpenStrategy.access$2(OpenStrategy.java:269)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:309)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-21 10:46:30.231
!MESSAGE Resource is out of sync with the file system: '/QRef/NodeServer/lib/security/UserAuth.js'.

!ENTRY org.eclipse.core.jobs 4 2 2012-09-21 10:46:39.014
!MESSAGE An internal error occurred during: "Requesting JavaScript AST from selection".
!STACK 0
java.lang.NullPointerException

!ENTRY org.apache.log4j 4 0 2012-09-21 10:48:43.062
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role._id)
					
					db.User.where('userName')
						.equals(userName)
						.find((err, arrObjs) ->
							if err?
								callback(err, false, 1)
								return
							if arrObjs? and arrObjs.length > 0
								callback(null, false, 2)
								return
							else
								user.save((err) ->
									if err?
										callback(err, false, 3)
									else
										callback(null, true, 0)
								)
							
						)
				
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) ->
					
					if err?
						callback(err, null)
						return
					if not tk?
						callback(true, null)
						return
					
					callback(null, tk.user)
		
				)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
					
					db.Role.where('roleName')
						.equals(roleName)
						.findOne((err, role) ->
							if err?
								callback(err, false)
								return
							
							if not role?
								callback(null, false)
								return
							
							bFound = false
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if item.toString() == role._id.toString()
										bFound = true
									cb(null)
								, (err) ->
									callback(null, bFound)
							)
						)
				)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
						
					arrQueryEntries = []
					
					arrQueryEntries.push({ roleName: r }) for r in roles
					
					db.Role.find({ "$or": arrQueryEntries })
						.exec((err, arrRoles) ->
							if err?
								callback(err, false)
								return
							
							if arrRoles.length == 0
								callback(null, false)
								return
							
							bFound = false
							dctRoleKeys = new Dictionary()
							
							dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
							
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if dctRoleKeys.containsKey(item.toString())
										bFound = true
									cb(null)
								, (err) ->
									callback(err, bFound)
							)
						)
				)
module.exports = new UserAuth()<<<
Document event: offset: 6897, length: 1, timestamp: 1756
text:><



!ENTRY org.apache.log4j 4 0 2012-09-21 10:49:03.717
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role._id)
					
					db.User.where('userName')
						.equals(userName)
						.find((err, arrObjs) ->
							if err?
								callback(err, false, 1)
								return
							if arrObjs? and arrObjs.length > 0
								callback(null, false, 2)
								return
							else
								user.save((err) ->
									if err?
										callback(err, false, 3)
									else
										callback(null, true, 0)
								)
							
						)
					
						)
				
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) ->
					
					if err?
						callback(err, null)
						return
					if not tk?
						callback(true, null)
						return
					
					callback(null, tk.user)
		
				)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
					
					db.Role.where('roleName')
						.equals(roleName)
						.findOne((err, role) ->
							if err?
								callback(err, false)
								return
							
							if not role?
								callback(null, false)
								return
							
							bFound = false
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if item.toString() == role._id.toString()
										bFound = true
									cb(null)
								, (err) ->
									callback(null, bFound)
							)
						)
				)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
						
					arrQueryEntries = []
					
					arrQueryEntries.push({ roleName: r }) for r in roles
					
					db.Role.find({ "$or": arrQueryEntries })
						.exec((err, arrRoles) ->
							if err?
								callback(err, false)
								return
							
							if arrRoles.length == 0
								callback(null, false)
								return
							
							bFound = false
							dctRoleKeys = new Dictionary()
							
							dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
							
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if dctRoleKeys.containsKey(item.toString())
										bFound = true
									cb(null)
								, (err) ->
									callback(err, bFound)
							)
						)
				)
module.exports = new UserAuth()<<<
Document event: offset: 6898, length: 1, timestamp: 1758
text:><



!ENTRY org.apache.log4j 4 0 2012-09-21 10:49:05.182
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
				.equals('Users')
				.findOne((err, role) ->
					
					if err?
						callback(err, false, 4)
						return
					
					if not role?
						callback(err, false, 5)
						return
					
					user = new db.User()
					user._id = userGuid
					user.passwordSalt = userSalt
					user.passwordHash = userHash
					user.emailAddress = userName
					user.userName = userName
					user.roles.push(role._id)
					
					db.User.where('userName')
						.equals(userName)
						.find((err, arrObjs) ->
							if err?
								callback(err, false, 1)
								return
							if arrObjs? and arrObjs.length > 0
								callback(null, false, 2)
								return
							else
								user.save((err) ->
									if err?
										callback(err, false, 3)
									else
										callback(null, true, 0)
								)
							
						)
					
					)
				
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) ->
					
					if err?
						callback(err, null)
						return
					if not tk?
						callback(true, null)
						return
					
					callback(null, tk.user)
		
				)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
					
					db.Role.where('roleName')
						.equals(roleName)
						.findOne((err, role) ->
							if err?
								callback(err, false)
								return
							
							if not role?
								callback(null, false)
								return
							
							bFound = false
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if item.toString() == role._id.toString()
										bFound = true
									cb(null)
								, (err) ->
									callback(null, bFound)
							)
						)
				)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
						
					arrQueryEntries = []
					
					arrQueryEntries.push({ roleName: r }) for r in roles
					
					db.Role.find({ "$or": arrQueryEntries })
						.exec((err, arrRoles) ->
							if err?
								callback(err, false)
								return
							
							if arrRoles.length == 0
								callback(null, false)
								return
							
							bFound = false
							dctRoleKeys = new Dictionary()
							
							dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
							
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if dctRoleKeys.containsKey(item.toString())
										bFound = true
									cb(null)
								, (err) ->
									callback(err, bFound)
							)
						)
				)
module.exports = new UserAuth()<<<
Document event: offset: 6905, length: 1, timestamp: 1759
text:><



!ENTRY org.apache.log4j 4 0 2012-09-21 10:49:28.951
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
			.equals('Users')
			.findOne((err, role) ->
				
				if err?
					callback(err, false, 4)
					return
				
				if not role?
					callback(err, false, 5)
					return
				
				user = new db.User()
				user._id = userGuid
				user.passwordSalt = userSalt
				user.passwordHash = userHash
				user.emailAddress = userName
				user.userName = userName
				user.roles.push(role._id)
				
				db.User.where('userName')
					.equals(userName)
					.find((err, arrObjs) ->
						if err?
							callback(err, false, 1)
							return
						if arrObjs? and arrObjs.length > 0
							callback(null, false, 2)
							return
						else
							user.save((err) ->
								if err?
									callback(err, false, 3)
								else
									callback(null, true, 0)
							)
						
					)
				
				)
			)
			
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) ->
					
					if err?
						callback(err, null)
						return
					if not tk?
						callback(true, null)
						return
					
					callback(null, tk.user)
		
				)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
					
					db.Role.where('roleName')
						.equals(roleName)
						.findOne((err, role) ->
							if err?
								callback(err, false)
								return
							
							if not role?
								callback(null, false)
								return
							
							bFound = false
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if item.toString() == role._id.toString()
										bFound = true
									cb(null)
								, (err) ->
									callback(null, bFound)
							)
						)
				)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
						
					arrQueryEntries = []
					
					arrQueryEntries.push({ roleName: r }) for r in roles
					
					db.Role.find({ "$or": arrQueryEntries })
						.exec((err, arrRoles) ->
							if err?
								callback(err, false)
								return
							
							if arrRoles.length == 0
								callback(null, false)
								return
							
							bFound = false
							dctRoleKeys = new Dictionary()
							
							dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
							
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if dctRoleKeys.containsKey(item.toString())
										bFound = true
									cb(null)
								, (err) ->
									callback(err, bFound)
							)
						)
				)
module.exports = new UserAuth()<<<
Document event: offset: 6872, length: 1, timestamp: 1802
text:><



!ENTRY org.apache.log4j 4 0 2012-09-21 10:49:32.617
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
Dictionary = require('../collections/Dictionary')
###
Secure utility methods for managing users, credentials, and tokens.
@author Nathan Klick
@copyright QRef 2012
###
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		db.Roles.where('roleName')
			.equals('Users')
			.findOne((err, role) ->
				
				if err?
					callback(err, false, 4)
					return
				
				if not role?
					callback(err, false, 5)
					return
				
				user = new db.User()
				user._id = userGuid
				user.passwordSalt = userSalt
				user.passwordHash = userHash
				user.emailAddress = userName
				user.userName = userName
				user.roles.push(role._id)
				
				db.User.where('userName')
					.equals(userName)
					.find((err, arrObjs) ->
						if err?
							callback(err, false, 1)
							return
						if arrObjs? and arrObjs.length > 0
							callback(null, false, 2)
							return
						else
							user.save((err) ->
								if err?
									callback(err, false, 3)
								else
									callback(null, true, 0)
							)
						
					)
				
				)
			
			
		
	###
	Retrieves the associate user account for a secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthUserFromTokenCallback} method.
	###
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) ->
					
					if err?
						callback(err, null)
						return
					if not tk?
						callback(true, null)
						return
					
					callback(null, tk.user)
		
				)
	###
	Determines if the currently authenticated user is in the given role.
	@param token [String] A hexadecimal string representing a secure token.
	@param roleName [String] The name of the role. 
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInRole: (token, roleName, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
					
					db.Role.where('roleName')
						.equals(roleName)
						.findOne((err, role) ->
							if err?
								callback(err, false)
								return
							
							if not role?
								callback(null, false)
								return
							
							bFound = false
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if item.toString() == role._id.toString()
										bFound = true
									cb(null)
								, (err) ->
									callback(null, bFound)
							)
						)
				)
	###
	Determines if the currently authenticated user is in any of the listed roles.
	@param token [String] A hexadecimal string representing a secure token.
	@param roles [Array<String>] The array of roles for which to check for membership.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthIsInRoleCallback} method.
	###
	isInAnyRole: (token, roles, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
				.equals(token)
				.populate('user')
				.findOne((err, tk) -> 
					
					if err?
						callback(err, false);
						return
						
					if not tk?
						callback(null, false);	
						return
						
					arrQueryEntries = []
					
					arrQueryEntries.push({ roleName: r }) for r in roles
					
					db.Role.find({ "$or": arrQueryEntries })
						.exec((err, arrRoles) ->
							if err?
								callback(err, false)
								return
							
							if arrRoles.length == 0
								callback(null, false)
								return
							
							bFound = false
							dctRoleKeys = new Dictionary()
							
							dctRoleKeys.set(r._id.toString(), r.roleName) for r in arrRoles
							
							
							async.forEach(tk.user.roles, 
								(item, cb) ->
									if dctRoleKeys.containsKey(item.toString())
										bFound = true
									cb(null)
								, (err) ->
									callback(err, bFound)
							)
						)
				)
module.exports = new UserAuth()<<<
Document event: offset: 6872, length: 1, timestamp: 1803
text:><


