!SESSION 2012-09-12 12:27:54.091 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_1.log
Created Time: 2012-09-13 14:09:49.419

!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:49.419
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, succes)
module.exports = Callbacks<<<
Document event: offset: 2167, length: 0, timestamp: 1829
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:49.572
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success)
module.exports = Callbacks<<<
Document event: offset: 2168, length: 0, timestamp: 1830
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:49.795
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success,)
module.exports = Callbacks<<<
Document event: offset: 2169, length: 0, timestamp: 1831
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:50.026
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, )
module.exports = Callbacks<<<
Document event: offset: 2170, length: 0, timestamp: 1832
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:58.389
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, s)
module.exports = Callbacks<<<
Document event: offset: 2171, length: 0, timestamp: 1833
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:58.581
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, st)
module.exports = Callbacks<<<
Document event: offset: 2172, length: 0, timestamp: 1834
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:58.669
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, sta)
module.exports = Callbacks<<<
Document event: offset: 2173, length: 0, timestamp: 1835
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:58.778
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, stat)
module.exports = Callbacks<<<
Document event: offset: 2174, length: 0, timestamp: 1836
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:09:58.923
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, state)
module.exports = Callbacks<<<
Document event: offset: 2175, length: 0, timestamp: 1837
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:05.947
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, e) ->
module.exports = Callbacks<<<
Document event: offset: 2171, length: 5, timestamp: 1841
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:06.190
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, er) ->
module.exports = Callbacks<<<
Document event: offset: 2172, length: 0, timestamp: 1842
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:06.338
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, err) ->
module.exports = Callbacks<<<
Document event: offset: 2173, length: 0, timestamp: 1843
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:06.464
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, erro) ->
module.exports = Callbacks<<<
Document event: offset: 2174, length: 0, timestamp: 1844
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:06.574
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, error) ->
module.exports = Callbacks<<<
Document event: offset: 2175, length: 0, timestamp: 1845
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:07.196
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, errorC) ->
module.exports = Callbacks<<<
Document event: offset: 2176, length: 0, timestamp: 1846
text:>C<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:07.376
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, errorCo) ->
module.exports = Callbacks<<<
Document event: offset: 2177, length: 0, timestamp: 1847
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:07.858
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, errorCod) ->
module.exports = Callbacks<<<
Document event: offset: 2178, length: 0, timestamp: 1848
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:08.114
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
		
	userAuthCreateAccountCallback: (err, success, errorCode) ->
module.exports = Callbacks<<<
Document event: offset: 2179, length: 0, timestamp: 1849
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:10:09.684
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Specification class for the purpose of documenting the signatures and parameters of the callback utilized in the application framework.
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Callbacks
	###
	Standard callback used in the DB Manager utility classes for deeply populating a single object.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param item [Object] The resulting deeply populated object.
	###
	managerExpandItemCallback: (err, item) ->
	###
	Standard callback used in the DB Manager utility class for deeply populating arrays of objects.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param newArray [Array<Object>] The resulting deeply populated array of objects.
	###
	managerExpandArrayCallback: (err, newArray) ->
	###
	Standard callback used by the {UserAuth} security routines to return the status of a credential validation operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	###
	userAuthValidateCredentialCallback: (err, isValid) ->
	###
	Standard callback used by the {UserAuth#login} method to return the status and token from an authentication operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param token [String] A valid token if successful otherwise null.
	@param isValid [Boolean] An true/false value indicating if the credential was valid. True indicates a valid credential while false indicates failure or invalid credentials.
	### 
	userAuthLoginCallback: (err, token, isValid) ->
	###
	Standard callback used by the {UserAuth#userFromToken} method to return the status and user from a lookup operation.
	@param err [Error] An error object if an error occurred or null otherwise.
	@param user [UserSchemaInternal] The user associated with the token or null if failed.
	###
	userAuthUserFromTokenCallback: (err, user) ->
	
	userAuthCreateAccountCallback: (err, success, errorCode) ->
module.exports = Callbacks<<<
Document event: offset: 2121, length: 1, timestamp: 1850
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:13:33.203
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 235, length: 1, timestamp: 67
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:14:15.981
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 459, length: 1, timestamp: 178
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:17:02.856
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string represential a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 1034, length: 1, timestamp: 707
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:17:04.205
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string represential a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	@
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 1035, length: 1, timestamp: 710
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:17:04.317
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string represential a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 1034, length: 1, timestamp: 711
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:18:25.421
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 1462, length: 1, timestamp: 968
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:20:16.159
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
			
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2182, length: 1, timestamp: 1274
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:20:16.573
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
		
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2181, length: 1, timestamp: 1275
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:20:16.760
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2180, length: 1, timestamp: 1276
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:21:19.107
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
					
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2789, length: 1, timestamp: 1468
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:21:19.406
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
				
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2788, length: 1, timestamp: 1469
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:21:19.575
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
			
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2787, length: 1, timestamp: 1470
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:21:19.729
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
		
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2786, length: 1, timestamp: 1471
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:21:19.897
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
		
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 2785, length: 1, timestamp: 1472
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:22:59.834
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 3975, length: 1, timestamp: 1781
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:24:17.625
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 4387, length: 1, timestamp: 1995
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:25:18.970
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
					
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 5297, length: 1, timestamp: 2153
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:25:19.127
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
				
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 5296, length: 1, timestamp: 2154
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:25:19.298
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
			
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 5295, length: 1, timestamp: 2155
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:25:19.474
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
		
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 5294, length: 1, timestamp: 2156
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:25:19.673
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 5293, length: 1, timestamp: 2157
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:26:47.629
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
			
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 6407, length: 1, timestamp: 2457
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:26:47.823
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
		
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 6406, length: 1, timestamp: 2458
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:26:48.018
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>crypto = require('crypto')
mongoose = require('mongoose')
QRefDatabase = require('../db/QRefDatabase')
ObjectId = mongoose.Types.ObjectId
class UserAuth 
	###
	Creates a new UserAuth object instance.
	###
	constructor: () ->
	###
	Generates a random salt.
	@return [String] A hexadecimal string representing a SHA-512 hash.
	###
	salt: () -> 
		hash = crypto.createHash('sha512')
		hash.update(crypto.randomBytes(1024))
		hash.digest('hex')
	###
	Performs an HMAC transformation on a password using a given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@param password [String] The clear text password to be encoded.
	@return [String] A hexadecimal string representing a secure SHA-512 HMAC representation of the clear text password.
	###
	securePassword: (key, salt, password) ->
		sKey = key + salt
		hmac = crypto.createHmac('sha512', sKey)
		hmac.update(password)
		hmac.digest('hex')
	###
	Generates a random secure token using the given key and salt values.
	@param key [String] The key to use with the HMAC algorithm.
	@param salt [String] A hexadecimal string representing a SHA-512 salt value.
	@return [String] A hexadecimal string representing a secure random token.
	###
	secureToken: (key, salt) ->
		sPassword = '' + Date.now() + crypto.randomBytes(64)
		@.securePassword(key, salt, sPassword)
	###
	Validates a given userName and password against the database.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateCredential: (userName, password, callback) ->
		db = QRefDatabase.instance()
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) => 
					if err? 
						callback(err, false)
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						callback(null, pwHash == user.passwordHash)
					else
						callback(null, false)
				)
	###
	Validate a secure token against the database records.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) =>
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		callback(null, Date.now() < obj.expiresOn)
					 	else
					 		callback(null, false)
					 )
	###
	Validates a set of user credentials against the database and issues a valid token if the credentials are valid.
	@param userName [String] The username to validate.
	@param password [String] The clear text password to validate.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthLoginCallback} method.
	###
	login: (userName, password, callback) ->
		db = QRefDatabase.instance()
	
			
		db.User.where('userName')
				.equals(userName)
				.findOne((err, user) =>
					if err?
						callback(err, null, false)
						return
					if user?
						pwHash = @.securePassword(user._id, user.passwordSalt, password)
						
						if pwHash == user.passwordHash
							expiry = new Date()
							expiry.setHours(expiry.getHours() + 336)
							tk = new db.AuthToken()
							tk.token = @.secureToken(user._id, user.passwordSalt)
							tk.expiresOn = expiry
							tk.user = user
							tk.save((error) ->
								if error?
									callback(error, null, false)
								else
									callback(null, tk.token, true)
							) 
						else
							callback(null, null, false)
					else
						callback(null, null, false)
		)
	###
	A helper method user to extract a token from the Authorization HTTP header and pass it to the {#validateToken} method.
	@param req [Express.Request] The HTTP request object.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	validateRequest: (req, callback) ->
		@.validateToken(req.header('Authorization'), callback)
	###
	Validates and extends the life of an existing secure token.
	@param token [String] A hexadecimal string representing a secure token.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthValidateCredentialCallback} method.
	###
	refreshToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					 .equals(token)
					 .findOne((err, obj) ->
					 	if err?
					 		callback(err, false)
					 		return
					 	if obj?
					 		if Date.now() < obj.expiresOn
					 			expiry = new Date()
					 			expiry.setHours(expiry.getHours() + 336)
					 			obj.expiresOn =  expiry
					 			obj.save((error) ->
					 				if error?
					 					callback(error, false)
					 				else
					 					callback(null, true) 
					 			)
					 		else
					 			callback(null, false)
					 	else
					 		callback(null, false)
					 )
	###
	Creates a new user account with no roles.
	@param userName [String] The userName to create. This should always be the email address of the user.
	@param password [String] The clear text password provided by the user.
	@param callback [Function] A function meeting the requirements of the {Callbacks#userAuthCreateAccountCallback} method.
	###
	createAccount: (userName, password, callback) ->
		db = QRefDatabase.instance()
		userSalt = @.salt()
		userGuid = new ObjectId()
		userHash = @.securePassword(userGuid, userSalt, password)
		
		user = new db.User()
		user._id = userGuid
		user.passwordSalt = userSalt
		user.passwordHash = userHash
		user.emailAddress = userName
		user.userName = userName
		
		db.User.where('userName')
				.equals(userName)
				.find((err, arrObjs) ->
					if err?
						callback(err, false, 1)
						return
					if arrObjs? and arrObjs.length > 0
						callback(null, false, 2)
						return
					else
						user.save((err) ->
							if err?
								callback(err, false, 3)
							else
								callback(null, true, 0)
						)
					
				)
	
	userFromToken: (token, callback) ->
		db = QRefDatabase.instance()
		db.AuthToken.where('token')
					.equals(token)
					.populate('user')
					.findOne((err, tk) ->
						
						if err?
							callback(err, null)
							return
						if not tk?
							callback(true, null)
							return
						
						callback(null, tk.user)
			
					)
module.exports = new UserAuth()<<<
Document event: offset: 6405, length: 1, timestamp: 2459
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:29:48.822
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')
class Router
	express: null
	routes: []
	constructor: (express) ->
		@express = express
	getExpress: () -> @express
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 943, length: 4, timestamp: 2
text:>@<



!ENTRY org.apache.log4j 4 0 2012-09-13 14:39:48.654
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')

###
Provides core request handling functionality and permits the auto-loading of routes at runtime.
@note Internal Usage Only - Not required outside the express bootstrap script.
@todo Remove dependency on relative and hard-coded paths.
@author Nathan Klick
@copyright QRef 2012
###
class Router
	
	express: null
	routes: []
	constructor: (express) ->
		@express = express
	getExpress: () -> @express
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 355, length: 1, timestamp: 421
text:><



!ENTRY org.apache.log4j 2 0 2012-09-13 14:40:22.849
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,354:1,355 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:40:27.333
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,257:1,258 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:40:37.070
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,227:1,228 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:40:44.732
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,213:1,214 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:40:49.875
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,111:1,112 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:40:57.967
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,088:1,089 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:41:31.090
!MESSAGE csep.parser.Lexer  - Unexpected symbol [935:936 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-13 14:41:34.033
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')

###
Provides core request handling functionality and permits the auto-loading of routes at runtime.
@note Internal Usage Only - Not required outside the express bootstrap script.
@todo Remove dependency on relative and hard-coded paths.
@author Nathan Klick
@copyright QRef 2012
###
class Router
	###
	@property [Express] A reference to the current express object instance.
	###
	express: null
	###
	@property [Array<Route>] The list of routes associated with and loaded by this router instance.
	###
	routes: []
	###
	Creates a new Router object instance attached to the specific express object instance.
	@param express [Express] A reference to the current express object instance.
	###
	constructor: (express) ->
		@express = express
	
	getExpress: () -> @express
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 810, length: 1, timestamp: 787
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:43:22.869
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')

###
Provides core request handling functionality and permits the auto-loading of routes at runtime.
@note Internal Usage Only - Not required outside the express bootstrap script.
@todo Remove dependency on relative and hard-coded paths.
@author Nathan Klick
@copyright QRef 2012
###
class Router
	###
	@property [Express] A reference to the current express object instance.
	###
	express: null
	###
	@property [Array<Route>] The list of routes associated with and loaded by this router instance.
	###
	routes: []
	###
	Creates a new Router object instance attached to the specific express object instance.
	@param express [Express] A reference to the current express object instance.
	###
	constructor: (express) ->
		@express = express
	###
	Accessor method for retrieving the current express object instance.
	@return [Express] The express object instance.
	###
	getExpress: () -> @express
	###
	Adds a new {Route} to the list of routes associated with this {Router}.
	@param route [Route] The route to be associated with this Router.
	@return [Boolean] True on success, false otherwise.
	###
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 1277, length: 1, timestamp: 1141
text:><



!ENTRY org.apache.log4j 2 0 2012-09-13 14:43:23.423
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,491:1,492 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:43:45.642
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,299:1,300 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-13 14:44:21.515
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')

###
Provides core request handling functionality and permits the auto-loading of routes at runtime.
@note Internal Usage Only - Not required outside the express bootstrap script.
@todo Remove dependency on relative and hard-coded paths.
@author Nathan Klick
@copyright QRef 2012
###
class Router
	###
	@property [Express] A reference to the current express object instance.
	###
	express: null
	###
	@property [Array<Route>] The list of routes associated with and loaded by this router instance.
	###
	routes: []
	###
	Creates a new Router object instance attached to the specific express object instance.
	@param express [Express] A reference to the current express object instance.
	###
	constructor: (express) ->
		@express = express
	###
	Accessor method for retrieving the current express object instance.
	@return [Express] The express object instance.
	###
	getExpress: () -> @express
	###
	Adds a new {Route} to the list of routes associated with this {Router}.
	@param route [Route] The route to be associated with this Router.
	@return [Boolean] True on success, false otherwise.
	###
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	###
	Installs the {Route} objects associated with this router into the express runtime.
	###
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 2032, length: 1, timestamp: 1311
text:><



!ENTRY org.apache.log4j 2 0 2012-09-13 14:44:29.764
!MESSAGE csep.parser.Lexer  - Unexpected symbol [2,031:2,032 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 14:45:01.718
!MESSAGE csep.parser.Lexer  - Unexpected symbol [2,143:2,144 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-13 14:45:07.190
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')

###
Provides core request handling functionality and permits the auto-loading of routes at runtime.
@note Internal Usage Only - Not required outside the express bootstrap script.
@todo Remove dependency on relative and hard-coded paths.
@author Nathan Klick
@copyright QRef 2012
###
class Router
	###
	@property [Express] A reference to the current express object instance.
	###
	express: null
	###
	@property [Array<Route>] The list of routes associated with and loaded by this router instance.
	###
	routes: []
	###
	Creates a new Router object instance attached to the specific express object instance.
	@param express [Express] A reference to the current express object instance.
	###
	constructor: (express) ->
		@express = express
	###
	Accessor method for retrieving the current express object instance.
	@return [Express] The express object instance.
	###
	getExpress: () -> @express
	###
	Adds a new {Route} to the list of routes associated with this {Router}.
	@param route [Route] The route to be associated with this Router.
	@return [Boolean] True on success, false otherwise.
	###
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	###
	Installs the {Route} objects associated with this router into the express runtime.
	###
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	###
	Dynamically loads the {Route} objects into the router from the 'routes' sub-directory.
	###
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 2222, length: 1, timestamp: 1447
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:45:16.516
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
fs = require('fs')

###
Provides core request handling functionality and permits the auto-loading of routes at runtime.
@note Internal Usage Only - Not required outside the express bootstrap script.
@todo Remove dependency on relative and hard-coded paths.
@author Nathan Klick
@copyright QRef 2012
###
class Router
	###
	@property [Express] A reference to the current express object instance.
	###
	express: null
	###
	@property [Array<Route>] The list of routes associated with and loaded by this router instance.
	###
	routes: []
	###
	Creates a new Router object instance attached to the specific express object instance.
	@param express [Express] A reference to the current express object instance.
	###
	constructor: (express) ->
		@express = express
	###
	Accessor method for retrieving the current express object instance.
	@return [Express] The express object instance.
	###
	getExpress: () -> @express
	###
	Adds a new {Route} to the list of routes associated with this {Router}.
	@param route [Route] The route to be associated with this Router.
	@return [Boolean] True on success, false otherwise.
	###
	registerRoute: (route) ->
		if route? and not (route in @routes)
			@routes.push route
		true
	###
	Installs the {Route} objects associated with this router into the express runtime.
	###
	setup: () ->
		console.log('Router: Route Count ' + @routes.length)
		for rt in @routes
			for m in rt.getMethods()
				console.log('Setup Route: ' + m.method + ' ' + m.path)
				if m.method == 'GET'
					@express.get(m.path, rt.get)
					console.log('Install Route: GET ' + m.path)
				else if m.method == 'POST'
					@express.post(m.path, rt.post)
					console.log('Install Route: POST ' + m.path)
				else if m.method == 'PUT'
					@express.put(m.path, rt.put)
					console.log('Install Route: PUT ' + m.path)
				else if m.method == 'DELETE'
					@express.del(m.path, rt.del)
					console.log('Install Route: DELETE ' + m.path)
		true
	###
	Dynamically loads the {Route} objects into the router from the 'routes' sub-directory.
	###
	load: () ->
		@.internalLoadDirectory('./lib/router/routes', './routes', '/services')
	###
	@private
	###
	internalLoadDirectory: (path, requirePath, webPath) ->
		entries = fs.readdirSync(path)
		for e in entries
			stats = fs.statSync(this.combinePath(path, e))
			
			if stats.isFile() and not (e.indexOf('.js') == -1)
				route = require(this.combinePath(requirePath, e))
				for m in route.getMethods()
					m.path = this.combinePath(webPath, m.path)
				this.registerRoute(route)
			else if stats.isDirectory()
				this.internalLoadDirectory(this.combinePath(path, e), this.combinePath(requirePath, e), this.combinePath(webPath, e))
		true
	
	combinePath: (path1, path2) ->
		if not (path1.lastIndexOf('/') == path1.length - 1)
			path1 = path1 + '/'
		
		if path2.indexOf('/') == 0
			path2 = path2.slice(1, path2.length) 
		
		path1 + path2		
module.exports = Router<<<
Document event: offset: 2798, length: 1, timestamp: 1465
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:47:54.724
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Object used by the {Route} class to map HTTP verbs to URL paths.
@author Nathan Klick
@copyright QRef 2012
###
class RouteMethod
	###
	@property [String] The HTTP verb to register. Should be one of ['GET', 'POST', 'PUT', 'DELETE'].
	###
	method: null
	@@
	<<<
Document event: offset: 268, length: 1, timestamp: 277
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:47:54.891
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Object used by the {Route} class to map HTTP verbs to URL paths.
@author Nathan Klick
@copyright QRef 2012
###
class RouteMethod
	###
	@property [String] The HTTP verb to register. Should be one of ['GET', 'POST', 'PUT', 'DELETE'].
	###
	method: null
	@
	<<<
Document event: offset: 267, length: 1, timestamp: 278
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:47:55.019
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Object used by the {Route} class to map HTTP verbs to URL paths.
@author Nathan Klick
@copyright QRef 2012
###
class RouteMethod
	###
	@property [String] The HTTP verb to register. Should be one of ['GET', 'POST', 'PUT', 'DELETE'].
	###
	method: null
	
	<<<
Document event: offset: 266, length: 1, timestamp: 279
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:48:21.913
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Object used by the {Route} class to map HTTP verbs to URL paths.
@author Nathan Klick
@copyright QRef 2012
###
class RouteMethod
	###
	@property [String] The HTTP verb to register. Should be one of ['GET', 'POST', 'PUT', 'DELETE'].
	###
	method: null
	###
	@property [String] The relative path to register for the verb.
	###
	path: null

	<<<
Document event: offset: 355, length: 1, timestamp: 369
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:48:23.243
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Object used by the {Route} class to map HTTP verbs to URL paths.
@author Nathan Klick
@copyright QRef 2012
###
class RouteMethod
	###
	@property [String] The HTTP verb to register. Should be one of ['GET', 'POST', 'PUT', 'DELETE'].
	###
	method: null
	###
	@property [String] The relative path to register for the verb.
	###
	path: null
mod
	<<<
Document event: offset: 358, length: 1, timestamp: 374
text:><



!ENTRY org.eclipse.ui 4 0 2012-09-13 14:50:36.478
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: The feature 'lines' is not a valid feature
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eStructuralFeature(BasicEObjectImpl.java:739)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eObjectForURIFragmentSegment(BasicEObjectImpl.java:533)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:780)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:756)
	at org.eclipse.xtext.resource.XtextResource.access$1(XtextResource.java:1)
	at org.eclipse.xtext.resource.XtextResource$1.getEObject(XtextResource.java:104)
	at org.eclipse.xtext.resource.DefaultFragmentProvider.getEObject(DefaultFragmentProvider.java:26)
	at org.eclipse.xtext.resource.XtextResource.getEObject(XtextResource.java:289)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:219)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:219)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:162)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:1)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.readOnly(AbstractReadWriteAcces.java:32)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.readOnly(XtextDocument.java:78)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.readOnly(AbstractOutlineNode.java:158)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.getChildren(AbstractOutlineNode.java:77)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:136)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.selectInTreeView(OutlineWithEditorLinker.java:125)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker$TextListener.selectionChanged(OutlineWithEditorLinker.java:69)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2749)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2697)
	at org.eclipse.jface.text.TextViewer$5.run(TextViewer.java:2676)
	at org.eclipse.swt.widgets.Display.runTimer(Display.java:4266)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3353)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.apache.log4j 4 0 2012-09-13 14:53:13.730
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Basic definition of a route that supports GET, POST, PUT, and DELETE HTTP verbs. 
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Route
	###
	@property [Array<RouteMethod>] The array of HTTP methods to register with the express runtime. 
	###
	methods: [{method: 'GET', path: null }, {method: 'POST', path: null}, {method: 'PUT', path: null}, {method: 'DELETE', path: null}]
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) -> 
		@methods = methods if methods?
	
	getMethods: () -> @methods
	post: (req, res) ->
	get: (req, res) ->
	put: (req, res) ->
	del: (req, res) ->
	
module.exports = Route
<<<
Document event: offset: 645, length: 1, timestamp: 481
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:55:02.266
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Basic definition of a route that supports GET, POST, PUT, and DELETE HTTP verbs. 
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Route
	###
	@property [Array<RouteMethod>] The array of HTTP methods to register with the express runtime. 
	###
	methods: [{method: 'GET', path: null }, {method: 'POST', path: null}, {method: 'PUT', path: null}, {method: 'DELETE', path: null}]
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) -> 
		@methods = methods if methods?
	###
	Accessor for the list of methods to be registered with the router.
	@return [Array<RouteMethod>] The array of {RouteMethod} objects.
	###
	getMethods: () -> @methods
	###
	Invoked when a POST request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	post: (req, res) ->
	###
	Invoked when a POST request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	get: (req, res) ->
	put: (req, res) ->
	del: (req, res) ->
	
module.exports = Route
<<<
Document event: offset: 1064, length: 1, timestamp: 844
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:55:07.842
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Basic definition of a route that supports GET, POST, PUT, and DELETE HTTP verbs. 
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Route
	###
	@property [Array<RouteMethod>] The array of HTTP methods to register with the express runtime. 
	###
	methods: [{method: 'GET', path: null }, {method: 'POST', path: null}, {method: 'PUT', path: null}, {method: 'DELETE', path: null}]
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) -> 
		@methods = methods if methods?
	###
	Accessor for the list of methods to be registered with the router.
	@return [Array<RouteMethod>] The array of {RouteMethod} objects.
	###
	getMethods: () -> @methods
	###
	Invoked when a POST request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	post: (req, res) ->
	###
	Invoked when a GET request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	get: (req, res) ->
	
	put: (req, res) ->
	del: (req, res) ->
	
module.exports = Route
<<<
Document event: offset: 1304, length: 1, timestamp: 849
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 14:55:13.252
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>###
Basic definition of a route that supports GET, POST, PUT, and DELETE HTTP verbs. 
@author Nathan Klick
@copyright QRef 2012
@abstract
###
class Route
	###
	@property [Array<RouteMethod>] The array of HTTP methods to register with the express runtime. 
	###
	methods: [{method: 'GET', path: null }, {method: 'POST', path: null}, {method: 'PUT', path: null}, {method: 'DELETE', path: null}]
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) -> 
		@methods = methods if methods?
	###
	Accessor for the list of methods to be registered with the router.
	@return [Array<RouteMethod>] The array of {RouteMethod} objects.
	###
	getMethods: () -> @methods
	###
	Invoked when a POST request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	post: (req, res) ->
	###
	Invoked when a GET request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	get: (req, res) ->
	###
	Invoked when a PUT request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	put: (req, res) ->
	
	del: (req, res) ->
	
module.exports = Route
<<<
Document event: offset: 1544, length: 1, timestamp: 855
text:><



!ENTRY org.apache.log4j 2 0 2012-09-13 14:56:38.737
!MESSAGE csep.parser.Lexer  - Unexpected symbol [557:558 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 15:07:56.886
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,550:1,551 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 15:11:03.745
!MESSAGE csep.parser.Lexer  - Unexpected symbol [2,668:2,669 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 2 0 2012-09-13 15:12:25.984
!MESSAGE csep.parser.Lexer  - Unexpected symbol [806:807 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-13 15:21:20.086
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
AjaxResponse = require('../serialization/AjaxResponse')
### 
A route which only supports AJAX operations (HTTP GET & POST).
@author Nathan Klick
@copyright QRef 2012
###
class AjaxRoute extends Route
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) ->
		super methods
	
	put: (req, res) ->
		resp = new AjaxResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	del: (req, res) ->
		resp = new AjaxResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
module.exports = AjaxRoute<<<
Document event: offset: 458, length: 1, timestamp: 124
text:><



!ENTRY org.apache.log4j 2 0 2012-09-13 15:21:20.914
!MESSAGE csep.parser.Lexer  - Unexpected symbol [840:841 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-13 15:21:26.528
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
RpcResponse = require('../serialization/RpcResponse')
### 
A route which only supports RPC operations (HTTP POST).
@author Nathan Klick
@copyright QRef 2012
###
class RpcRoute extends Route
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) ->
		super methods
	get: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	
	put: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	del: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
module.exports = RpcRoute<<<
Document event: offset: 567, length: 1, timestamp: 14
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 15:21:35.385
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
AjaxResponse = require('../serialization/AjaxResponse')
### 
A route which only supports AJAX operations (HTTP GET & POST).
@author Nathan Klick
@copyright QRef 2012
###
class AjaxRoute extends Route
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) ->
		super methods
	###
	Invoked when a PUT request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	put: (req, res) ->
		resp = new AjaxResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	
	del: (req, res) ->
		resp = new AjaxResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
module.exports = AjaxRoute<<<
Document event: offset: 797, length: 1, timestamp: 127
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 15:21:50.418
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
RpcResponse = require('../serialization/RpcResponse')
### 
A route which only supports RPC operations (HTTP POST).
@author Nathan Klick
@copyright QRef 2012
###
class RpcRoute extends Route
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) ->
		super methods
	get: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	###
	Invoked when a PUT request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	put: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	
	del: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
module.exports = RpcRoute<<<
Document event: offset: 905, length: 1, timestamp: 17
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 15:22:13.514
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>Route = require('./Route')
RpcResponse = require('../serialization/RpcResponse')
### 
A route which only supports RPC operations (HTTP POST).
@author Nathan Klick
@copyright QRef 2012
###
class RpcRoute extends Route
	###
	Create a new Route object instance and registers the given methods with the router.
	@param methods [Array<RouteMethod>] The methods to register with the router.
	###
	constructor: (methods) ->
		super methods
	
	get: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	###
	Invoked when a PUT request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	put: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
	###
	Invoked when a DELETE request is received by the express runtime on the registered URL.
	@param req [Express.Request] The express request object.
	@param res [Express.Response] The express response object.
	###
	del: (req, res) ->
		resp = new RpcResponse(null)
		resp.failure('Method Not Allowed', 405)
		res.json(resp, 200)
module.exports = RpcRoute<<<
Document event: offset: 448, length: 1, timestamp: 20
text:><



!ENTRY org.apache.log4j 2 0 2012-09-13 15:22:14.068
!MESSAGE csep.parser.Lexer  - Unexpected symbol [1,162:1,163 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:90)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:44)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:254)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2012-09-13 16:01:46.084
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UPd<<<
Document event: offset: 196, length: 1, timestamp: 211
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:01:46.350
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UP<<<
Document event: offset: 195, length: 1, timestamp: 212
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:01:46.852
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class U<<<
Document event: offset: 194, length: 1, timestamp: 213
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:01:51.210
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateChecklistAJa<<<
Document event: offset: 211, length: 1, timestamp: 232
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:01:51.368
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateChecklistAJ<<<
Document event: offset: 210, length: 1, timestamp: 233
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:01:51.514
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateChecklistA<<<
Document event: offset: 209, length: 1, timestamp: 234
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:32.454
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 199, length: 0, timestamp: 2
text:>A<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:32.668
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAiChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 200, length: 0, timestamp: 3
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:32.949
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAirChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 201, length: 0, timestamp: 4
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:33.058
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 202, length: 0, timestamp: 5
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:33.317
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircrChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 203, length: 0, timestamp: 6
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:33.493
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 204, length: 0, timestamp: 7
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:33.618
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircrafChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 205, length: 0, timestamp: 8
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:33.769
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 206, length: 0, timestamp: 9
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:40.177
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 199, length: 0, timestamp: 2
text:>A<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:40.368
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAiChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 200, length: 0, timestamp: 3
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:40.646
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAirChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 201, length: 0, timestamp: 4
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:40.759
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 202, length: 0, timestamp: 5
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:41.273
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircrChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 203, length: 0, timestamp: 6
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:41.580
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircrfChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 204, length: 0, timestamp: 7
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:41.727
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircrfaChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 205, length: 0, timestamp: 8
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:42.160
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircrfChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 205, length: 1, timestamp: 9
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:42.365
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircrChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 204, length: 1, timestamp: 10
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:42.431
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircraChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 204, length: 0, timestamp: 11
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:42.648
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircrafChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 205, length: 0, timestamp: 12
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:06:42.791
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false <<<
Document event: offset: 206, length: 0, timestamp: 13
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-13 16:07:25.671
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false 
	<<<
Document event: offset: 2568, length: 1, timestamp: 15
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:07:26.093
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to update a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Optional) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Optional) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false 
<<<
Document event: offset: 2567, length: 1, timestamp: 16
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:07:45.158
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false 
	<<<
Document event: offset: 2568, length: 1, timestamp: 11
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:07:45.339
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false 
<<<
Document event: offset: 2567, length: 1, timestamp: 12
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:07:46.455
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false 
	<<<
Document event: offset: 2568, length: 1, timestamp: 15
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 16:07:46.700
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a checklist.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftChecklistAjaxRequest extends AjaxRequest
	###
	@property [ObjectId] (Required) The manufacturer that this checklist is built against.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model that this checklist is built against.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [Number] (Optional) The order in which this checklist should appear relative to the other checklists.
	###
	index: 
		type: Number
		required: false
		default: null
	###
	@property [String] (Optional) The tail number for a list which has been customized to a specific plane.
	###
	tailNumber:
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Optional) The user which owns this customized version of the checklist.
	@see UserSchemaInternal
	###
	user:
		type: ObjectId
		ref: 'users'
		required: false
		default: null
	###
	@property [Number] (Optional) The version number of this checklist. 
	###
	version:
		type: Number
		required: true
		default: 1
	###
	@property [String] (Optional) A server-based relative path to the product icon. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of preflight sections.
	###
	preflight:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of takeoff sections.
	###
	takeoff:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of landing sections.
	###
	landing: 
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Array<AircraftChecklistSectionSchemaInternal>] (Optional) The array of emergency sections.
	###
	emergencies:
		type: [AircraftChecklistSectionSchema]
		required: false
	###
	@property [Boolean] (Optional) A true/false value indicating whether this record has been deleted. Required for soft-delete support.
	###
	isDeleted:
		type: Boolean
		required: true
		default: false 
<<<
Document event: offset: 2567, length: 1, timestamp: 16
text:><



!ENTRY org.eclipse.jface.text 4 0 2012-09-13 16:52:19.794
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.NullPointerException
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:669)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:674)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:387)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:443)
	at org.eclipse.wst.jsdt.internal.core.CompilationUnitProblemFinder.accept(CompilationUnitProblemFinder.java:174)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForBinding(LookupEnvironment.java:279)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:132)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:766)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:720)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.Scope.getJavaLangString(Scope.java:1745)
	at org.eclipse.wst.jsdt.core.dom.DefaultBindingResolver.resolveExpressionType(DefaultBindingResolver.java:604)
	at org.eclipse.wst.jsdt.core.dom.Expression.resolveTypeBinding(Expression.java:111)
	at org.eclipse.wst.jsdt.internal.corext.refactoring.nls.NLSHintHelper.getAccessorClassReference(NLSHintHelper.java:97)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo(NLSStringHover.java:96)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getHoverInfo2(AbstractJavaEditorTextHover.java:95)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:147)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:78)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jface.text 4 0 2012-09-13 17:07:34.975
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.NullPointerException
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:669)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:674)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:387)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:443)
	at org.eclipse.wst.jsdt.internal.core.CompilationUnitProblemFinder.accept(CompilationUnitProblemFinder.java:174)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForBinding(LookupEnvironment.java:279)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:132)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:766)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:720)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.Scope.getJavaLangString(Scope.java:1745)
	at org.eclipse.wst.jsdt.core.dom.DefaultBindingResolver.resolveExpressionType(DefaultBindingResolver.java:604)
	at org.eclipse.wst.jsdt.core.dom.Expression.resolveTypeBinding(Expression.java:111)
	at org.eclipse.wst.jsdt.internal.corext.refactoring.nls.NLSHintHelper.getAccessorClassReference(NLSHintHelper.java:97)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo(NLSStringHover.java:96)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getHoverInfo2(AbstractJavaEditorTextHover.java:95)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:147)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:78)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jface.text 4 0 2012-09-13 17:17:11.929
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.NullPointerException
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:669)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:674)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:387)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:443)
	at org.eclipse.wst.jsdt.internal.core.CompilationUnitProblemFinder.accept(CompilationUnitProblemFinder.java:174)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForBinding(LookupEnvironment.java:279)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:132)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:766)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:720)
	at org.eclipse.wst.jsdt.internal.compiler.lookup.Scope.getJavaLangString(Scope.java:1745)
	at org.eclipse.wst.jsdt.core.dom.DefaultBindingResolver.resolveExpressionType(DefaultBindingResolver.java:604)
	at org.eclipse.wst.jsdt.core.dom.Expression.resolveTypeBinding(Expression.java:111)
	at org.eclipse.wst.jsdt.internal.corext.refactoring.nls.NLSHintHelper.getAccessorClassReference(NLSHintHelper.java:97)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo(NLSStringHover.java:96)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getHoverInfo2(AbstractJavaEditorTextHover.java:95)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:147)
	at org.eclipse.wst.jsdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:78)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.288
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isTriggerPoint(NavigatorContentDescriptor.java:426)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForTriggerPoint(NavigatorContentDescriptorManager.java:187)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsByTriggerPoint(NavigatorContentService.java:805)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findContentExtensionsByTriggerPoint(NavigatorContentService.java:654)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findContentExtensionsByTriggerPoint(NavigatorContentService.java:635)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.hasChildren(NavigatorContentServiceContentProvider.java:377)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.hasChildren(NavigatorContentServiceContentProvider.java:422)
	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2123)
	at org.eclipse.jface.viewers.TreeViewer.isExpandable(TreeViewer.java:588)
	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2153)
	at org.eclipse.jface.viewers.AbstractTreeViewer.updatePlus(AbstractTreeViewer.java:2835)
	at org.eclipse.jface.viewers.TreeViewer.updatePlus(TreeViewer.java:852)
	at org.eclipse.jface.viewers.AbstractTreeViewer.updateChildren(AbstractTreeViewer.java:2728)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1908)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1915)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1915)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1883)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1840)
	at org.eclipse.ui.navigator.CommonViewer.internalRefresh(CommonViewer.java:561)
	at org.eclipse.jface.viewers.StructuredViewer$8.run(StructuredViewer.java:1535)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1443)
	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:403)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1404)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1533)
	at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:548)
	at org.eclipse.ui.navigator.CommonViewer.refresh(CommonViewer.java:350)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider$4.run(PackageExplorerContentProvider.java:1451)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider.runUpdates(PackageExplorerContentProvider.java:194)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider.runPendingUpdates(PackageExplorerContentProvider.java:186)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider$1.runInUIThread(PackageExplorerContentProvider.java:164)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.289
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.293
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isTriggerPoint(NavigatorContentDescriptor.java:426)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForTriggerPoint(NavigatorContentDescriptorManager.java:187)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsByTriggerPoint(NavigatorContentService.java:805)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findContentExtensionsByTriggerPoint(NavigatorContentService.java:654)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findContentExtensionsByTriggerPoint(NavigatorContentService.java:635)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.hasChildren(NavigatorContentServiceContentProvider.java:377)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.hasChildren(NavigatorContentServiceContentProvider.java:422)
	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2123)
	at org.eclipse.jface.viewers.TreeViewer.isExpandable(TreeViewer.java:588)
	at org.eclipse.jface.viewers.AbstractTreeViewer.isExpandable(AbstractTreeViewer.java:2153)
	at org.eclipse.jface.viewers.AbstractTreeViewer.optionallyPruneChildren(AbstractTreeViewer.java:2785)
	at org.eclipse.jface.viewers.AbstractTreeViewer.updateChildren(AbstractTreeViewer.java:2585)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1908)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1915)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1915)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1915)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:721)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1883)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1840)
	at org.eclipse.ui.navigator.CommonViewer.internalRefresh(CommonViewer.java:561)
	at org.eclipse.jface.viewers.StructuredViewer$8.run(StructuredViewer.java:1535)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1443)
	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:403)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1404)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1533)
	at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:548)
	at org.eclipse.ui.navigator.CommonViewer.refresh(CommonViewer.java:350)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider$4.run(PackageExplorerContentProvider.java:1451)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider.runUpdates(PackageExplorerContentProvider.java:194)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider.runPendingUpdates(PackageExplorerContentProvider.java:186)
	at org.eclipse.wst.jsdt.internal.ui.packageview.PackageExplorerContentProvider$1.runInUIThread(PackageExplorerContentProvider.java:164)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.294
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.805
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getStyledText(NavigatorContentServiceLabelProvider.java:145)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getStyledText(NavigatorDecoratingLabelProvider.java:68)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getStyledText(DelegatingStyledCellLabelProvider.java:195)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getStyledText(DecoratingStyledCellLabelProvider.java:192)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:103)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.ui.navigator.CommonViewer.doUpdateItem(CommonViewer.java:409)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.updateItem(ResourceToItemsMapper.java:142)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.objectChanged(ResourceToItemsMapper.java:131)
	at org.eclipse.ui.navigator.CommonViewer.handleLabelProviderChanged(CommonViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:97)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:74)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:72)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:77)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:430)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:428)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:529)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.806
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.808
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:102)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getImage(NavigatorDecoratingLabelProvider.java:60)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getImage(DelegatingStyledCellLabelProvider.java:184)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getImage(DecoratingStyledCellLabelProvider.java:167)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:118)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.ui.navigator.CommonViewer.doUpdateItem(CommonViewer.java:409)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.updateItem(ResourceToItemsMapper.java:142)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.objectChanged(ResourceToItemsMapper.java:131)
	at org.eclipse.ui.navigator.CommonViewer.handleLabelProviderChanged(CommonViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:97)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:74)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:72)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:77)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:430)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:428)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:529)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.809
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.811
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getFont(NavigatorContentServiceLabelProvider.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getFont(NavigatorDecoratingLabelProvider.java:129)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getFont(DelegatingStyledCellLabelProvider.java:168)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getFont(DecoratingStyledCellLabelProvider.java:163)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:119)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.ui.navigator.CommonViewer.doUpdateItem(CommonViewer.java:409)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.updateItem(ResourceToItemsMapper.java:142)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.objectChanged(ResourceToItemsMapper.java:131)
	at org.eclipse.ui.navigator.CommonViewer.handleLabelProviderChanged(CommonViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:97)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:74)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:72)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:77)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:430)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:428)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:529)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.811
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.813
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getForeground(NavigatorContentServiceLabelProvider.java:224)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getForeground(NavigatorDecoratingLabelProvider.java:119)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getForeground(DelegatingStyledCellLabelProvider.java:137)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getForeground(DecoratingStyledCellLabelProvider.java:144)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:120)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.ui.navigator.CommonViewer.doUpdateItem(CommonViewer.java:409)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.updateItem(ResourceToItemsMapper.java:142)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.objectChanged(ResourceToItemsMapper.java:131)
	at org.eclipse.ui.navigator.CommonViewer.handleLabelProviderChanged(CommonViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:97)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:74)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:72)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:77)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:430)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:428)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:529)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.814
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.core.resources 4 1 2012-09-13 17:25:42.815
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:269)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:108)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:60)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)
	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)
	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.CustomAndExpression.evaluate(CustomAndExpression.java:71)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin$Evaluator.run(NavigatorPlugin.java:245)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorPlugin.safeEvaluate(NavigatorPlugin.java:260)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptor.isPossibleChild(NavigatorContentDescriptor.java:454)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptors(NavigatorContentDescriptorManager.java:236)
	at org.eclipse.ui.internal.navigator.extensions.NavigatorContentDescriptorManager.findDescriptorsForPossibleChild(NavigatorContentDescriptorManager.java:206)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findDescriptorsWithPossibleChild(NavigatorContentService.java:842)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findPossibleLabelExtensions(NavigatorContentService.java:457)
	at org.eclipse.ui.internal.navigator.NavigatorContentService.findRelevantLabelProviders(NavigatorContentService.java:496)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getBackground(NavigatorContentServiceLabelProvider.java:242)
	at org.eclipse.ui.internal.navigator.NavigatorDecoratingLabelProvider$StyledLabelProviderAdapter.getBackground(NavigatorDecoratingLabelProvider.java:109)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getBackground(DelegatingStyledCellLabelProvider.java:153)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getBackground(DecoratingStyledCellLabelProvider.java:154)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:121)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:134)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:152)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:938)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:106)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1018)
	at org.eclipse.ui.navigator.CommonViewer.doUpdateItem(CommonViewer.java:409)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.updateItem(ResourceToItemsMapper.java:142)
	at org.eclipse.ui.internal.navigator.resources.ResourceToItemsMapper.objectChanged(ResourceToItemsMapper.java:131)
	at org.eclipse.ui.navigator.CommonViewer.handleLabelProviderChanged(CommonViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:97)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:74)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:49)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:72)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:77)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:430)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:428)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:529)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2012-09-13 17:25:42.816
!MESSAGE Resource is out of sync with the file system: '/QRef/WebContent/css/theme-dark.css'.

!ENTRY org.eclipse.jface.text 4 0 2012-09-13 17:41:14.236
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.NullPointerException

!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:34.063
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('')
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1045, length: 0, timestamp: 56
text:>''<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:45.152
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAUth
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 927, length: 1, timestamp: 73
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:45.308
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAUt
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 926, length: 1, timestamp: 74
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:45.458
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAU
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 925, length: 1, timestamp: 75
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:45.627
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserA
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 924, length: 1, timestamp: 76
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:52.866
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 941, length: 2, timestamp: 95
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:54.176
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(t)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 942, length: 0, timestamp: 97
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:54.346
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(to)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 943, length: 0, timestamp: 98
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:54.553
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(tok)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 944, length: 0, timestamp: 99
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:54.670
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(toke)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 945, length: 0, timestamp: 100
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:54.826
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 946, length: 0, timestamp: 101
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:55.258
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token,)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 947, length: 0, timestamp: 102
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:55.406
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, )
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 948, length: 0, timestamp: 103
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:56.524
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, ())
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 949, length: 0, timestamp: 104
text:>()<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:56.758
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (e))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 950, length: 0, timestamp: 105
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:56.974
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (er))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 951, length: 0, timestamp: 106
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:57.138
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 952, length: 0, timestamp: 107
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:57.399
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err,))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 953, length: 0, timestamp: 108
text:>,<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:57.598
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, ))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 954, length: 0, timestamp: 109
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:59.128
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, u))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 955, length: 0, timestamp: 110
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:59.215
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, us))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 956, length: 0, timestamp: 111
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:59.443
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, use))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 957, length: 0, timestamp: 112
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:19:59.648
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user))
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 958, length: 0, timestamp: 113
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:00.414
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) )
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 960, length: 0, timestamp: 114
text:> <



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:01.241
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) -)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 961, length: 0, timestamp: 115
text:>-<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:01.758
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) ->)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 962, length: 0, timestamp: 116
text:>><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:02.192
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) ->
				
			)
			# Validate Admin Only Access
			
			query = db.AircraftChecklist.find()
			query.where('isDeleted', false)
			query.where('user', )
		
			if req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
			else if req.query?.pageSize? and not req.query?.page?
				query = query.limit(req.query.pageSize)
			else if not req.query?.pageSize? and req.query?.page?
				query = query.skip(req.query.page * 25).limit(25)
			
			query.exec((err, arrObjs) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Internal Error', 500)
					res.json(resp, 200)
					return
					
				db.AircraftChecklist.count((err, count) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
					
					#console.log('Expanding records.')
					mgr.expandAll(arrObjs, (err, arrCheckLists) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
							
						#console.log('Returning expanded records.')
						resp = new AjaxResponse()
						resp.addRecords(arrCheckLists)
						resp.setTotal(count)
						res.json(resp, 200)
					)
					
				)
				
			)
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 963, length: 0, timestamp: 117
text:>
				
			<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:24.989
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) ->
				
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1018, length: 1260, timestamp: 118
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:37.424
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) ->
				
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 969, length: 1, timestamp: 120
text:><



!ENTRY org.apache.log4j 4 0 2012-09-13 18:20:58.247
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) ->
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', )
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 969, length: 0, timestamp: 164
text:>
				<



!ENTRY org.apache.log4j 4 0 2012-09-13 18:21:21.052
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRoute = require('../../../AjaxRoute')
AjaxResponse = require('../../../../serialization/AjaxResponse')
UserAuth = require('../../../../security/UserAuth')
QRefDatabase = require('../../../../db/QRefDatabase')
ChecklistManager = require('../../../../db/manager/ChecklistManager')
class AircraftChecklistsRoute extends AjaxRoute
	constructor: () ->
		super [{ method: 'POST', path: '/checklists' }, { method: 'GET', path: '/checklists' }]
	get: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		mgr = new ChecklistManager()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
			
			UserAuth.userFromToken(token, (err, user) ->
				if err?
					resp = new AjaxResponse()
					resp.failure('Not Authorized', 403)
					res.json(resp, 200)
					return
				
				
				query = db.AircraftChecklist.find()
				query.where('isDeleted', false)
				query.where('user', )
			
				if req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * req.query.pageSize).limit(req.query.pageSize)
				else if req.query?.pageSize? and not req.query?.page?
					query = query.limit(req.query.pageSize)
				else if not req.query?.pageSize? and req.query?.page?
					query = query.skip(req.query.page * 25).limit(25)
				
				query.exec((err, arrObjs) ->
					if err?
						resp = new AjaxResponse()
						resp.failure('Internal Error', 500)
						res.json(resp, 200)
						return
						
					db.AircraftChecklist.count((err, count) ->
						if err?
							resp = new AjaxResponse()
							resp.failure('Internal Error', 500)
							res.json(resp, 200)
							return
						
						#console.log('Expanding records.')
						mgr.expandAll(arrObjs, (err, arrCheckLists) ->
							if err?
								resp = new AjaxResponse()
								resp.failure('Internal Error', 500)
								res.json(resp, 200)
								return
								
							#console.log('Returning expanded records.')
							resp = new AjaxResponse()
							resp.addRecords(arrCheckLists)
							resp.setTotal(count)
							res.json(resp, 200)
						)
						
					)
					
				)
			)
			# Validate Admin Only Access
			
			
		)
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new AjaxResponse()
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		token = req.param('token')
		
		UserAuth.validateToken(token, (err, isTokenValid) ->
			if err? or not isTokenValid == true
				resp = new AjaxResponse()
				resp.failure('Not Authorized', 403)
				res.json(resp, 200)
				return
				
			# Validate Permissions Here
			
			newObj = new db.AircraftChecklist()
	
			newObj.manufacturer = req.body.manufacturer
			newObj.model = req.body.model
			newObj.preflight = req.body.preflight
			newObj.takeoff = req.body.takeoff
			newObj.landing = req.body.landing
			newObj.emergencies = req.body.emergenices
			#newObj.modelYear = req.body.modelYear
			
			if req.body?.tailNumber?
				newObj.tailNumber = req.body.tailNumber
				
			if req.body?.index?
				newObj.index = req.body.index
				
			if req.body?.user?
				newObj.user = req.body.user
			
			if req.body?.version?
				newObj.version = req.body.version
			else 
				newObj.version = 1
			
			if req.body?.productIcon?
				newObj.productIcon = req.body.productIcon
			
			#if req.body?.coverImage?
			#	newObj.coverImage = req.body.coverImage
			
			newObj.save((err) ->
				if err?
					resp = new AjaxResponse()
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				resp = new AjaxResponse()
				resp.setTotal(1)
				resp.addRecord(newObj)
				res.json(resp, 200)
			)
			
		)
		

	isValidRequest: (req) ->
		if (req.query? and req.query?.token?) or
			  (req.body? and req.body?.token? and req.body?.model? and  
			 	req.body?.manufacturer? and req.body?.preflight? and req.body?.takeoff? and
			 	req.body?.landing? and req.body?.emergencies? and
			 	req.body?.mode? and req.body.mode == 'ajax')
			true
		else
			false 
	
module.exports = new AircraftChecklistsRoute()<<<
Document event: offset: 1095, length: 1, timestamp: 179
text:><



!ENTRY org.eclipse.ui 4 0 2012-09-14 11:07:13.241
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: The feature 'body' is not a valid feature
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eStructuralFeature(BasicEObjectImpl.java:739)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eObjectForURIFragmentSegment(BasicEObjectImpl.java:557)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:780)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:756)
	at org.eclipse.xtext.resource.XtextResource.access$1(XtextResource.java:1)
	at org.eclipse.xtext.resource.XtextResource$1.getEObject(XtextResource.java:104)
	at org.eclipse.xtext.resource.DefaultFragmentProvider.getEObject(DefaultFragmentProvider.java:26)
	at org.eclipse.xtext.resource.XtextResource.getEObject(XtextResource.java:289)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:219)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:219)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:162)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:1)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.readOnly(AbstractReadWriteAcces.java:32)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.readOnly(XtextDocument.java:78)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.readOnly(AbstractOutlineNode.java:158)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.getChildren(AbstractOutlineNode.java:77)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:136)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.selectInTreeView(OutlineWithEditorLinker.java:125)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker$TextListener.selectionChanged(OutlineWithEditorLinker.java:69)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2749)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2697)
	at org.eclipse.jface.text.TextViewer$5.run(TextViewer.java:2676)
	at org.eclipse.swt.widgets.Display.runTimer(Display.java:4266)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3353)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:37.077
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CAircraftMa<<<
Document event: offset: 196, length: 0, timestamp: 32
text:>C<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:37.489
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CrAircraftMa<<<
Document event: offset: 197, length: 0, timestamp: 33
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:37.629
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreAircraftMa<<<
Document event: offset: 198, length: 0, timestamp: 34
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:37.838
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreaAircraftMa<<<
Document event: offset: 199, length: 0, timestamp: 35
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:37.894
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreatAircraftMa<<<
Document event: offset: 200, length: 0, timestamp: 36
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:38.056
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftMa<<<
Document event: offset: 201, length: 0, timestamp: 37
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:50.082
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftManufacturerAjaxRequest extends AJa<<<
Document event: offset: 245, length: 1, timestamp: 72
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:50.213
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftManufacturerAjaxRequest extends AJ<<<
Document event: offset: 244, length: 1, timestamp: 73
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:09:50.361
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftManufacturerAjaxRequest extends A<<<
Document event: offset: 243, length: 1, timestamp: 74
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:11:28.869
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a model.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftModelAJ<<<
Document event: offset: 210, length: 1, timestamp: 37
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:11:28.984
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a model.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftModelA<<<
Document event: offset: 209, length: 1, timestamp: 38
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:17:55.584
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftProductAjaxRequest extends <<<
Document event: offset: 232, length: 1, timestamp: 59
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:04.102
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a model.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftModelAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true
	<<<
Document event: offset: 846, length: 1, timestamp: 72
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:04.447
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a model.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftModelAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true
<<<
Document event: offset: 845, length: 1, timestamp: 73
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:06.109
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a model.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftModelAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true
mode<<<
Document event: offset: 849, length: 1, timestamp: 79
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:06.259
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a model.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftModelAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the model.
	### 
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A detailed description of the model.
	###
	description:
		type: String
		required: false
	###
	@property [ObjectId] (Required) The associated manufacturer of this model.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		required: true
		ref: 'aircraft.manufacturers'
	###
	@property [String] (Required) A string representing the specific year of this model.
	###
	modelYear:
		type: String
		required: true
mod<<<
Document event: offset: 848, length: 1, timestamp: 80
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:19.567
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftManufacturerAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the manufacturer.
	###
	name:
		type: String
		required: true
		unique: true
	###
	@property [String] (Optional) A detailed description of this manufacturer.
	###
	description:
		type: String
		required: false
	<<<
Document event: offset: 527, length: 1, timestamp: 88
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:19.881
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftManufacturerAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the manufacturer.
	###
	name:
		type: String
		required: true
		unique: true
	###
	@property [String] (Optional) A detailed description of this manufacturer.
	###
	description:
		type: String
		required: false
<<<
Document event: offset: 526, length: 1, timestamp: 89
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:21.779
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a manufacturer.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftManufacturerAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) The name of the manufacturer.
	###
	name:
		type: String
		required: true
		unique: true
	###
	@property [String] (Optional) A detailed description of this manufacturer.
	###
	description:
		type: String
		required: false
module<<<
Document event: offset: 532, length: 1, timestamp: 97
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:59.014
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
	<<<
Document event: offset: 3846, length: 1, timestamp: 74
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:18:59.214
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CreateAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
<<<
Document event: offset: 3845, length: 1, timestamp: 75
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:46.106
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CreatAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 196, length: 1, timestamp: 3
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:46.257
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CreaAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 195, length: 1, timestamp: 4
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:46.409
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CreAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 194, length: 1, timestamp: 5
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:46.573
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CrAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 193, length: 1, timestamp: 6
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:46.725
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class CAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 192, length: 1, timestamp: 7
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:46.879
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class AircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 191, length: 1, timestamp: 8
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:47.377
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class UAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 191, length: 0, timestamp: 9
text:>U<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:47.506
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class UpAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 192, length: 0, timestamp: 10
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:47.653
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class UpdAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 193, length: 0, timestamp: 11
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:47.853
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class UpdaAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 194, length: 0, timestamp: 12
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:47.992
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class UpdatAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 195, length: 0, timestamp: 13
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:19:48.120
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>AjaxRequest = require('../../../serialization/AjaxRequest')
###
Object sent as the body of an HTTP POST request to create a product.
@author Nathan Klick
@copyright QRef 2012
###
class UpdateAircraftProductAjaxRequest extends AjaxRequest
	###
	@property [String] (Required) A unique internal name for the product. Might possibly be a SKU or PN.
	###
	name:
		type: String
		required: true
	###
	@property [String] (Optional) A product description which will be visible on the product details screen.
	###
	description: 
		type: String
		required: false
		default: ''
	###
	@property [Boolean] (Required) A true/false value indicating whether the product is published for consumer user.
	###
	isPublished:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An apple product code for the corresponding item in the iTunes store.
	###
	appleProductIdentifier:
		type: String
		required: false
	###
	@property [String] (Optional) A google product code for the corresponding item in the google play store.
	###
	androidProductIdentifier:
		type: String
		required: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for apple devices.
	###
	isAppleEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is available for android devices.
	###
	isAndroidEnabled:
		type: Boolean
		required: true
		default: false
	###
	@property [Number] (Required) The suggested retail price for this product. Price may vary in iTunes and Google Play stores.
	###
	suggestedRetailPrice:
		type: Number
		required: true
		default: 0
		min: 0
		max: 100.00
	###
	@property [String] (Required) An enumeration indicating general product category. Valid values are ['aviation', 'marine', 'navigation'].
	###
	productCategory:
		type: String
		required: true
		enum: ['aviation', 'marine', 'navigation']
	###
	@property [String] (Required) An enumeration indicating the type of product. Valid values are ['checklist', 'manual', 'guide'].
	###
	productType:
		type: String
		required: true
		enum: ['checklist', 'manual', 'guide']
	###
	@property [ObjectId] (Optional) An associated base checklist for aircraft products. This category represents the stock checklist that the user receives when purchasing the product.
	###
	aircraftChecklist:
		type: ObjectId
		ref: 'aircraft.checklists'
		required: false
		default: null
	###
	@property [Boolean] (Required) A true/false value indicating whether this product is a sample product which is included with the application at no charge.
	###
	isSampleProduct:
		type: Boolean
		required: true
		default: false
	###
	@property [String] (Optional) An string indicating which aircraft, marine, or navigation serial numbers are supported by this product.
	###
	serialNumber: 
		type: String
		required: false
		default: null
	###
	@property [ObjectId] (Required) The manufacturer associated with this product.
	@see AircraftManufacturerSchemaInternal
	###
	manufacturer: 
		type: ObjectId
		ref: 'aircraft.manufacturers'
		required: true
	###
	@property [ObjectId] (Required) The model associated with this product.
	@see AircraftModelSchemaInternal
	###
	model: 
		type: ObjectId
		ref: 'aircraft.models'
		required: true
	###
	@property [String] (Optional) A server-based relative path to the cover artwork for this product. This path should be relative to the server root. 
	###
	coverImage:
		type: String
		required: false
	###
	@property [String] (Optional) A server-based relative path to the icon for this product. This path should be relative to the server root.
	###
	productIcon:
		type: String
		required: false
module.exports = CreateAircraftProductAjaxRequest<<<
Document event: offset: 196, length: 0, timestamp: 14
text:>e<



!ENTRY org.apache.log4j 2 0 2012-09-14 11:20:03.341
!MESSAGE csep.parser.Lexer  - Unexpected symbol [3,283:3,284 -4 ']

!STACK 0
java.lang.Exception
	at csep.parser.Lexer.nextToken(Lexer.java:68)
	at org.antlr.runtime.CommonTokenStream.fillBuffer(CommonTokenStream.java:119)
	at csep.parser.FirstCommentIncludingXtextTokenStream.toString(FirstCommentIncludingXtextTokenStream.java:26)
	at org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser.parse(AbstractInternalAntlrParser.java:524)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:102)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.parse(AbstractAntlrParser.java:84)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:62)
	at org.eclipse.xtext.parser.antlr.AbstractAntlrParser.doParse(AbstractAntlrParser.java:70)
	at org.eclipse.xtext.parser.AbstractParser.reparse(AbstractParser.java:38)
	at org.eclipse.xtext.resource.XtextResource.update(XtextResource.java:217)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:55)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconcilerUnitOfWork.process(XtextReconcilerUnitOfWork.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.modify(AbstractReadWriteAcces.java:49)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:181)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.process(XtextDocument.java:202)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$DocumentListener.performNecessaryUpdates(XtextReconciler.java:81)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.updateContentBeforeRead(XtextDocument.java:135)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.beforeReadOnly(XtextDocument.java:155)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.beforeReadOnly(XtextDocument.java:1)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.readOnly(AbstractReadWriteAcces.java:31)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.readOnly(XtextDocument.java:78)
	at org.eclipse.xtext.ui.editor.hyperlinking.DefaultHyperlinkDetector.detectHyperlinks(DefaultHyperlinkDetector.java:36)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:286)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:258)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:462)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:211)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4165)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3754)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui 4 0 2012-09-14 11:22:54.677
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: The feature 'body' is not a valid feature
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eStructuralFeature(BasicEObjectImpl.java:739)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eObjectForURIFragmentSegment(BasicEObjectImpl.java:557)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:780)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:756)
	at org.eclipse.xtext.resource.XtextResource.access$1(XtextResource.java:1)
	at org.eclipse.xtext.resource.XtextResource$1.getEObject(XtextResource.java:104)
	at org.eclipse.xtext.resource.DefaultFragmentProvider.getEObject(DefaultFragmentProvider.java:26)
	at org.eclipse.xtext.resource.XtextResource.getEObject(XtextResource.java:289)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:219)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:219)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:162)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:1)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.readOnly(AbstractReadWriteAcces.java:32)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.readOnly(XtextDocument.java:78)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.readOnly(AbstractOutlineNode.java:158)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.getChildren(AbstractOutlineNode.java:77)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:136)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.selectInTreeView(OutlineWithEditorLinker.java:125)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker$TextListener.selectionChanged(OutlineWithEditorLinker.java:69)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2749)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2697)
	at org.eclipse.jface.text.TextViewer$5.run(TextViewer.java:2676)
	at org.eclipse.swt.widgets.Display.runTimer(Display.java:4266)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3353)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:36.693
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	p: 
		type: String
		required: true
	
	<<<
Document event: offset: 596, length: 12, timestamp: 234
text:>p<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:36.823
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	pa: 
		type: String
		required: true
	
	<<<
Document event: offset: 597, length: 0, timestamp: 235
text:>a<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:37.059
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	pas: 
		type: String
		required: true
	
	<<<
Document event: offset: 598, length: 0, timestamp: 236
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:37.210
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	pass: 
		type: String
		required: true
	
	<<<
Document event: offset: 599, length: 0, timestamp: 237
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:37.441
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	passw: 
		type: String
		required: true
	
	<<<
Document event: offset: 600, length: 0, timestamp: 238
text:>w<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:37.583
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	passwo: 
		type: String
		required: true
	
	<<<
Document event: offset: 601, length: 0, timestamp: 239
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:37.715
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	passwor: 
		type: String
		required: true
	
	<<<
Document event: offset: 602, length: 0, timestamp: 240
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:36:37.944
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) A SHA-512 HMAC representing the user's password.
	###
	password: 
		type: String
		required: true
	
	<<<
Document event: offset: 603, length: 0, timestamp: 241
text:>d<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:37:27.617
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
	
<<<
Document event: offset: 643, length: 1, timestamp: 288
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:37:28.308
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
<<<
Document event: offset: 640, length: 1, timestamp: 290
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:37:30.022
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
modeu<<<
Document event: offset: 645, length: 1, timestamp: 297
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:37:30.183
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
mode<<<
Document event: offset: 644, length: 1, timestamp: 298
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:37:30.320
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
mod<<<
Document event: offset: 643, length: 1, timestamp: 299
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:16.619
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoginRpcRequest extends RpcRequest

module.exports = LoginRpcRequest<<<
Document event: offset: 302, length: 1, timestamp: 4
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:21.306
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LogiRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 270, length: 1, timestamp: 6
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:21.471
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LogRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 269, length: 1, timestamp: 7
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:21.627
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 268, length: 1, timestamp: 8
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:21.781
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 267, length: 1, timestamp: 9
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:21.932
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 266, length: 1, timestamp: 10
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:22.422
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 266, length: 0, timestamp: 11
text:>R<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:22.643
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class ReRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 267, length: 0, timestamp: 12
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:22.904
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 268, length: 0, timestamp: 13
text:>f<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:23.147
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefrRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 269, length: 0, timestamp: 14
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:23.515
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 270, length: 0, timestamp: 15
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:23.805
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefresRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 271, length: 0, timestamp: 16
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:24.063
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 272, length: 0, timestamp: 17
text:>h<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:24.467
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshTRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 273, length: 0, timestamp: 18
text:>T<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:24.678
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshToRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 274, length: 0, timestamp: 19
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:24.939
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshTokRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 275, length: 0, timestamp: 20
text:>k<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:25.090
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshTokeRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 276, length: 0, timestamp: 21
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:25.195
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshTokenRpcRequest extends RpcRequest
module.exports = LoginRpcRequest<<<
Document event: offset: 277, length: 0, timestamp: 22
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:38:28.520
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RefreshTokenRpcRequest extends RpcRequest
module.exports = RefreshTokenRpcRequest<<<
Document event: offset: 326, length: 15, timestamp: 23
text:>RefreshTokenRpcRequest<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:16.800
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LogiRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 270, length: 1, timestamp: 3
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:16.953
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LogRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 269, length: 1, timestamp: 4
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:17.119
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LoRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 268, length: 1, timestamp: 5
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:17.270
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class LRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 267, length: 1, timestamp: 6
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:17.705
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to perform user authentication.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 266, length: 1, timestamp: 7
text:><



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:32.783
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 264, length: 0, timestamp: 36
text:>R<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:32.995
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class ReRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 265, length: 0, timestamp: 37
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:33.250
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 266, length: 0, timestamp: 38
text:>g<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:33.389
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegiRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 267, length: 0, timestamp: 39
text:>i<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:33.517
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 268, length: 0, timestamp: 40
text:>s<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:33.692
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegistRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 269, length: 0, timestamp: 41
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:33.807
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisteRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 270, length: 0, timestamp: 42
text:>e<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:34.014
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 271, length: 0, timestamp: 43
text:>r<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:34.461
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterARpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 272, length: 0, timestamp: 44
text:>A<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:34.763
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAcRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 273, length: 0, timestamp: 45
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:34.933
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAccRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 274, length: 0, timestamp: 46
text:>c<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:35.056
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAccoRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 275, length: 0, timestamp: 47
text:>o<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:35.606
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAccouRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 276, length: 0, timestamp: 48
text:>u<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:35.873
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAccounRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 277, length: 0, timestamp: 49
text:>n<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:35.991
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAccountRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = LoginRpcRequest<<<
Document event: offset: 278, length: 0, timestamp: 50
text:>t<



!ENTRY org.apache.log4j 4 0 2012-09-14 11:39:40.117
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRequest = require('../../../serialization/RpcRequest')
###
Object sent as the body of an HTTP POST request to create a new user account.
@note The token property is not required when using this method.
@author Nathan Klick
@copyright QRef 2012
###
class RegisterAccountRpcRequest extends RpcRequest
	###
	@property [String] (Required) The username used to perform authentication. This should always be the user's email address.
	###
	userName: 
		type: String
		required: true
		unique: true
	###
	@property [String] (Required) The clear text version of the user's password.
	###
	password: 
		type: String
		required: true
module.exports = RegisterAccountRpcRequest<<<
Document event: offset: 665, length: 15, timestamp: 51
text:>RegisterAccountRpcRequest<



!ENTRY org.eclipse.ui 4 0 2012-09-14 11:43:32.327
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: The feature 'body' is not a valid feature
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eStructuralFeature(BasicEObjectImpl.java:739)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eObjectForURIFragmentSegment(BasicEObjectImpl.java:557)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:780)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:756)
	at org.eclipse.xtext.resource.XtextResource.access$1(XtextResource.java:1)
	at org.eclipse.xtext.resource.XtextResource$1.getEObject(XtextResource.java:104)
	at org.eclipse.xtext.resource.DefaultFragmentProvider.getEObject(DefaultFragmentProvider.java:26)
	at org.eclipse.xtext.resource.XtextResource.getEObject(XtextResource.java:289)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:219)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:219)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:162)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode$2.exec(AbstractOutlineNode.java:1)
	at org.eclipse.xtext.util.concurrent.AbstractReadWriteAcces.readOnly(AbstractReadWriteAcces.java:32)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.readOnly(XtextDocument.java:78)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.readOnly(AbstractOutlineNode.java:158)
	at org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode.getChildren(AbstractOutlineNode.java:77)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:136)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.findBestNode(OutlineWithEditorLinker.java:137)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker.selectInTreeView(OutlineWithEditorLinker.java:125)
	at org.eclipse.xtext.ui.editor.outline.actions.OutlineWithEditorLinker$TextListener.selectionChanged(OutlineWithEditorLinker.java:69)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2749)
	at org.eclipse.jface.text.TextViewer.firePostSelectionChanged(TextViewer.java:2697)
	at org.eclipse.jface.text.TextViewer$5.run(TextViewer.java:2676)
	at org.eclipse.swt.widgets.Display.runTimer(Display.java:4266)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3353)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2531)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3752)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
