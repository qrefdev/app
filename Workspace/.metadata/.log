!SESSION 2012-10-15 11:52:34.617 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.7.0_05
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\SourceControl\QRef\trunk\Workspace\.metadata\.bak_0.log
Created Time: 2012-10-15 12:32:59.350

!ENTRY org.apache.log4j 4 0 2012-10-15 12:32:59.350
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.ty)
			
			targetPath = fsPath + fileName
			targetWebPath = webPath + fileName
			
			fs.rename(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2016, length: 0, timestamp: 302
text:>y<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:32:59.577
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.typ)
			
			targetPath = fsPath + fileName
			targetWebPath = webPath + fileName
			
			fs.rename(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2017, length: 0, timestamp: 303
text:>p<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:32:59.678
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName
			targetWebPath = webPath + fileName
			
			fs.rename(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2018, length: 0, timestamp: 304
text:>e<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:01.808
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded productIcon and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/icon
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductIconRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/icon' }, { method: 'GET', path: '/product/icon' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/icons/'
		webPath = 'images/product/icons/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
			
			ext = mime.extension(file.type)
		
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.c(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.productIcon = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductIconRoute()<<<
Document event: offset: 2140, length: 6, timestamp: 194
text:>c<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:01.983
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded productIcon and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/icon
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductIconRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/icon' }, { method: 'GET', path: '/product/icon' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/icons/'
		webPath = 'images/product/icons/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
			
			ext = mime.extension(file.type)
		
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.co(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.productIcon = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductIconRoute()<<<
Document event: offset: 2141, length: 0, timestamp: 195
text:>o<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:02.039
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded productIcon and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/icon
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductIconRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/icon' }, { method: 'GET', path: '/product/icon' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/icons/'
		webPath = 'images/product/icons/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
			
			ext = mime.extension(file.type)
		
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.cop(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.productIcon = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductIconRoute()<<<
Document event: offset: 2142, length: 0, timestamp: 196
text:>p<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:02.272
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded productIcon and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/icon
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductIconRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/icon' }, { method: 'GET', path: '/product/icon' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/icons/'
		webPath = 'images/product/icons/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
			
			ext = mime.extension(file.type)
		
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.productIcon = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductIconRoute()<<<
Document event: offset: 2143, length: 0, timestamp: 197
text:>y<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:15.947
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.c(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2142, length: 6, timestamp: 337
text:>c<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:16.121
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.co(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2143, length: 0, timestamp: 338
text:>o<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:16.274
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.cop(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2144, length: 0, timestamp: 339
text:>p<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:43:16.621
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2145, length: 0, timestamp: 340
text:>y<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:14.711
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(f)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2717, length: 0, timestamp: 351
text:>f<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:14.910
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(fi)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2718, length: 0, timestamp: 352
text:>i<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:15.020
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(fil)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2719, length: 0, timestamp: 353
text:>l<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:15.190
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2720, length: 0, timestamp: 354
text:>e<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:15.379
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2721, length: 0, timestamp: 355
text:>.<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:15.663
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.p)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2722, length: 0, timestamp: 356
text:>p<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:15.881
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.pa)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2723, length: 0, timestamp: 357
text:>a<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:16.018
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.pat)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2724, length: 0, timestamp: 358
text:>t<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:16.125
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2725, length: 0, timestamp: 359
text:>h<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:16.788
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path,)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2726, length: 0, timestamp: 360
text:>,<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:16.902
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, )
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2727, length: 0, timestamp: 361
text:> <



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:17.391
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, ())
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2728, length: 0, timestamp: 362
text:>()<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:17.618
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (e))
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2729, length: 0, timestamp: 363
text:>e<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:17.804
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (er))
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2730, length: 0, timestamp: 364
text:>r<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:17.964
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err))
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2731, length: 0, timestamp: 365
text:>r<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:18.602
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err) )
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2733, length: 0, timestamp: 366
text:> <



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:18.937
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err) -)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2734, length: 0, timestamp: 367
text:>-<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:19.283
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err) ->)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2735, length: 0, timestamp: 368
text:>><



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:19.535
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err) -> )
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2736, length: 0, timestamp: 369
text:> <



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:21.255
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err) -> 
						
					)
					resp = new RpcResponse(targetWebPath)
					res.json(resp, 200)
					return
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2737, length: 0, timestamp: 370
text:>
						
					<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:24.950
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					fs.unlink(file.path, (err) -> 
						
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2760, length: 76, timestamp: 371
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:31.503
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
						fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2707, length: 0, timestamp: 375
text:>
						<



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:32.809
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2714, length: 1, timestamp: 376
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 12:58:44.275
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded productIcon and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/icon
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductIconRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/icon' }, { method: 'GET', path: '/product/icon' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/icons/'
		webPath = 'images/product/icons/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
			
			ext = mime.extension(file.type)
		
			
			targetPath = fsPath + fileName + "." + ext
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.productIcon = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductIconRoute()<<<
Document event: offset: 2713, length: 76, timestamp: 198
text:>fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)<



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:00.666
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileName
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2066, length: 12, timestamp: 377
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.114
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileNam
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2065, length: 1, timestamp: 378
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.133
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileNa
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2064, length: 1, timestamp: 379
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.157
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fileN
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2063, length: 1, timestamp: 380
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.181
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + file
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2062, length: 1, timestamp: 381
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.206
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fil
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2061, length: 1, timestamp: 382
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.230
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + fi
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2060, length: 1, timestamp: 383
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.254
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + f
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2059, length: 1, timestamp: 384
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:01.428
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + 
			targetWebPath = webPath + fileName + "." + ext
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2058, length: 1, timestamp: 385
text:><



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:06.330
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded coverImage and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/cover
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductCoverRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/cover' }, { method: 'GET', path: '/product/cover' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/covers/'
		webPath = 'images/product/covers/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
				
			ext = mime.extension(file.type)
			
			targetPath = fsPath + file.name
			targetWebPath = webPath + f
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.coverImage = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
					
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductCoverRoute()<<<
Document event: offset: 2098, length: 20, timestamp: 395
text:>f<



!ENTRY org.apache.log4j 4 0 2012-10-15 13:18:32.295
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>RpcRoute = require('../../../RpcRoute')
QRefDatabase = require('../../../../db/QRefDatabase')
RpcResponse = require('../../../../serialization/RpcResponse')
UserAuth = require('../../../../security/UserAuth')
https = require('https')
async = require('async')
fs = require('fs-extra')
mime = require('mime')
###
Service route that saves an uploaded productIcon and returns the final path to image.
@example Service Methods (see {ProductImageRpcRequest})
  Request Format: application/json
  Response Format: application/json
  
  POST /services/rpc/aircraft/product/icon
    @BODY - (Required) ProductImageRpcRequest
    
	Returns the next available version number in the returnValue field of the response object.
@author Nathan Klick
@copyright QRef 2012
###
class ProductIconRoute extends RpcRoute
	constructor: () ->
		super [{ method: 'POST', path: '/product/icon' }, { method: 'GET', path: '/product/icon' }]
	post: (req, res) =>
		if not @.isValidRequest(req)
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db = QRefDatabase.instance()
		fileKeys = Object.keys(req.files)
		token = req.param('token')
		productId = req.body.product
		
		fsPath = '/storage/http/qref/WebContent/images/product/icons/'
		webPath = 'images/product/icons/'
		
		if fileKeys.length == 0 or fileKeys.length > 1
			resp = new RpcResponse(null)
			resp.failure('Bad Request', 400)
			res.json(resp, 200)
			return
		
		db.Product.findById(productId, (err, product) ->
			if err?
				resp = new RpcResponse(null)
				resp.failure(err, 500)
				res.json(resp, 200)
				return
			
			if not product?
				resp = new RpcResponse(null)
				resp.failure('Not Found', 404)
				res.json(resp, 200)
				return
			
			file = req.files[fileKeys[0]]
			slashPos = file.path.lastIndexOf('/')
			
			if slashPos > 0
				fileName = file.path.slice(slashPos+1)
			else
				fileName = file.path
			
			ext = mime.extension(file.type)
		
			
			targetPath = fsPath + file.name
			targetWebPath = webPath + file.name
			
			fs.copy(file.path, targetPath, (err) ->
				if err?
					console.log("File System Error { targetPath: '" + targetPath + "', targetWebPath: '" + targetWebPath + "', slashPos: " + slashPos + ", fileName: '" + fileName + "', file.path: '" + file.path + "' }")
					resp = new RpcResponse(null)
					resp.failure(err, 500)
					res.json(resp, 200)
					return
				
				product.productIcon = targetWebPath
				
				product.save((err) ->
					if err?
						resp = new RpcResponse(null)
						resp.failure(err, 500)
						res.json(resp, 200)
						return
					
					fs.unlink(file.path, (err) -> 
						resp = new RpcResponse(targetWebPath)
						res.json(resp, 200)
						return
					)
				)
			)
			
			
			
			
		)
		
	
	isValidRequest: (req) ->
		if req.body? and req.body?.mode? and req.body.mode == 'rpc' and req.body?.product? and req.body?.token?
			true
		else
			false
module.exports = new ProductIconRoute()<<<
Document event: offset: 2034, length: 93, timestamp: 199
text:>targetPath = fsPath + file.name
			targetWebPath = webPath + file.name<


